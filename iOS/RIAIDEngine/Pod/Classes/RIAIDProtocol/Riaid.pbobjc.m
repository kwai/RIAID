// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: riaid.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "Riaid.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - RIAIDRiaidRoot

@implementation RIAIDRiaidRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - RIAIDRiaidRoot_FileDescriptor

static GPBFileDescriptor *RIAIDRiaidRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"riaid"
                                                 objcPrefix:@"RIAID"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum RIAIDCompareOperator

GPBEnumDescriptor *RIAIDCompareOperator_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "CompareOperatorUnknown\000CompareOperatorEq"
        "ual\000CompareOperatorNotEqual\000CompareOpera"
        "torLessThan\000CompareOperatorGreaterThan\000C"
        "ompareOperatorLessThanOrEqual\000CompareOpe"
        "ratorGreaterThanOrEqual\000";
    static const int32_t values[] = {
        RIAIDCompareOperator_CompareOperatorUnknown,
        RIAIDCompareOperator_CompareOperatorEqual,
        RIAIDCompareOperator_CompareOperatorNotEqual,
        RIAIDCompareOperator_CompareOperatorLessThan,
        RIAIDCompareOperator_CompareOperatorGreaterThan,
        RIAIDCompareOperator_CompareOperatorLessThanOrEqual,
        RIAIDCompareOperator_CompareOperatorGreaterThanOrEqual,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(RIAIDCompareOperator)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:RIAIDCompareOperator_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL RIAIDCompareOperator_IsValidValue(int32_t value__) {
  switch (value__) {
    case RIAIDCompareOperator_CompareOperatorUnknown:
    case RIAIDCompareOperator_CompareOperatorEqual:
    case RIAIDCompareOperator_CompareOperatorNotEqual:
    case RIAIDCompareOperator_CompareOperatorLessThan:
    case RIAIDCompareOperator_CompareOperatorGreaterThan:
    case RIAIDCompareOperator_CompareOperatorLessThanOrEqual:
    case RIAIDCompareOperator_CompareOperatorGreaterThanOrEqual:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum RIAIDLogicOperator

GPBEnumDescriptor *RIAIDLogicOperator_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "LogicOperatorUnknown\000LogicOperatorOr\000Log"
        "icOperatorAnd\000LogicOperatorNot\000";
    static const int32_t values[] = {
        RIAIDLogicOperator_LogicOperatorUnknown,
        RIAIDLogicOperator_LogicOperatorOr,
        RIAIDLogicOperator_LogicOperatorAnd,
        RIAIDLogicOperator_LogicOperatorNot,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(RIAIDLogicOperator)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:RIAIDLogicOperator_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL RIAIDLogicOperator_IsValidValue(int32_t value__) {
  switch (value__) {
    case RIAIDLogicOperator_LogicOperatorUnknown:
    case RIAIDLogicOperator_LogicOperatorOr:
    case RIAIDLogicOperator_LogicOperatorAnd:
    case RIAIDLogicOperator_LogicOperatorNot:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum RIAIDDeviceAxisType

GPBEnumDescriptor *RIAIDDeviceAxisType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "DeviceAxisTypeUnknown\000DeviceAxisTypeX\000De"
        "viceAxisTypeY\000DeviceAxisTypeZ\000";
    static const int32_t values[] = {
        RIAIDDeviceAxisType_DeviceAxisTypeUnknown,
        RIAIDDeviceAxisType_DeviceAxisTypeX,
        RIAIDDeviceAxisType_DeviceAxisTypeY,
        RIAIDDeviceAxisType_DeviceAxisTypeZ,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(RIAIDDeviceAxisType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:RIAIDDeviceAxisType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL RIAIDDeviceAxisType_IsValidValue(int32_t value__) {
  switch (value__) {
    case RIAIDDeviceAxisType_DeviceAxisTypeUnknown:
    case RIAIDDeviceAxisType_DeviceAxisTypeX:
    case RIAIDDeviceAxisType_DeviceAxisTypeY:
    case RIAIDDeviceAxisType_DeviceAxisTypeZ:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - RIAIDInt32Value

@implementation RIAIDInt32Value

@dynamic value;

typedef struct RIAIDInt32Value__storage_ {
  uint32_t _has_storage_[1];
  int32_t value;
} RIAIDInt32Value__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDInt32Value_FieldNumber_Value,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RIAIDInt32Value__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RIAIDInt32Value class]
                                     rootClass:[RIAIDRiaidRoot class]
                                          file:RIAIDRiaidRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RIAIDInt32Value__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RIAIDBoolValue

@implementation RIAIDBoolValue

@dynamic value;

typedef struct RIAIDBoolValue__storage_ {
  uint32_t _has_storage_[1];
} RIAIDBoolValue__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDBoolValue_FieldNumber_Value,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RIAIDBoolValue class]
                                     rootClass:[RIAIDRiaidRoot class]
                                          file:RIAIDRiaidRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RIAIDBoolValue__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RIAIDFloatValue

@implementation RIAIDFloatValue

@dynamic value;

typedef struct RIAIDFloatValue__storage_ {
  uint32_t _has_storage_[1];
  float value;
} RIAIDFloatValue__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDFloatValue_FieldNumber_Value,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RIAIDFloatValue__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RIAIDFloatValue class]
                                     rootClass:[RIAIDRiaidRoot class]
                                          file:RIAIDRiaidRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RIAIDFloatValue__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RIAIDBasicVariable

@implementation RIAIDBasicVariable

@dynamic key;
@dynamic name;
@dynamic hasValue, value;

typedef struct RIAIDBasicVariable__storage_ {
  uint32_t _has_storage_[1];
  int32_t key;
  NSString *name;
  RIAIDBasicVariableValue_Value *value;
} RIAIDBasicVariable__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "key",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDBasicVariable_FieldNumber_Key,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RIAIDBasicVariable__storage_, key),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDBasicVariable_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RIAIDBasicVariable__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "value",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDBasicVariableValue_Value),
        .number = RIAIDBasicVariable_FieldNumber_Value,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RIAIDBasicVariable__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RIAIDBasicVariable class]
                                     rootClass:[RIAIDRiaidRoot class]
                                          file:RIAIDRiaidRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RIAIDBasicVariable__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RIAIDBasicVariableValue

@implementation RIAIDBasicVariableValue


typedef struct RIAIDBasicVariableValue__storage_ {
  uint32_t _has_storage_[1];
} RIAIDBasicVariableValue__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RIAIDBasicVariableValue class]
                                     rootClass:[RIAIDRiaidRoot class]
                                          file:RIAIDRiaidRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(RIAIDBasicVariableValue__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum RIAIDBasicVariableValue_Type

GPBEnumDescriptor *RIAIDBasicVariableValue_Type_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "None\000Bool\000Integer\000Double\000String\000";
    static const int32_t values[] = {
        RIAIDBasicVariableValue_Type_None,
        RIAIDBasicVariableValue_Type_Bool,
        RIAIDBasicVariableValue_Type_Integer,
        RIAIDBasicVariableValue_Type_Double,
        RIAIDBasicVariableValue_Type_String,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(RIAIDBasicVariableValue_Type)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:RIAIDBasicVariableValue_Type_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL RIAIDBasicVariableValue_Type_IsValidValue(int32_t value__) {
  switch (value__) {
    case RIAIDBasicVariableValue_Type_None:
    case RIAIDBasicVariableValue_Type_Bool:
    case RIAIDBasicVariableValue_Type_Integer:
    case RIAIDBasicVariableValue_Type_Double:
    case RIAIDBasicVariableValue_Type_String:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - RIAIDBasicVariableValue_Value

@implementation RIAIDBasicVariableValue_Value

@dynamic type;
@dynamic b;
@dynamic i;
@dynamic d;
@dynamic s;

typedef struct RIAIDBasicVariableValue_Value__storage_ {
  uint32_t _has_storage_[1];
  RIAIDBasicVariableValue_Type type;
  NSString *s;
  int64_t i;
  double d;
} RIAIDBasicVariableValue_Value__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = RIAIDBasicVariableValue_Type_EnumDescriptor,
        .number = RIAIDBasicVariableValue_Value_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RIAIDBasicVariableValue_Value__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "b",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDBasicVariableValue_Value_FieldNumber_B,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "i",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDBasicVariableValue_Value_FieldNumber_I,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RIAIDBasicVariableValue_Value__storage_, i),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "d",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDBasicVariableValue_Value_FieldNumber_D,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(RIAIDBasicVariableValue_Value__storage_, d),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "s",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDBasicVariableValue_Value_FieldNumber_S,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(RIAIDBasicVariableValue_Value__storage_, s),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RIAIDBasicVariableValue_Value class]
                                     rootClass:[RIAIDRiaidRoot class]
                                          file:RIAIDRiaidRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RIAIDBasicVariableValue_Value__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(RIAIDBasicVariableValue)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RIAIDBasicVariableValue_Value_Type_RawValue(RIAIDBasicVariableValue_Value *message) {
  GPBDescriptor *descriptor = [RIAIDBasicVariableValue_Value descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RIAIDBasicVariableValue_Value_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetRIAIDBasicVariableValue_Value_Type_RawValue(RIAIDBasicVariableValue_Value *message, int32_t value) {
  GPBDescriptor *descriptor = [RIAIDBasicVariableValue_Value descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RIAIDBasicVariableValue_Value_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - RIAIDPoint

@implementation RIAIDPoint

@dynamic x;
@dynamic y;

typedef struct RIAIDPoint__storage_ {
  uint32_t _has_storage_[1];
  float x;
  float y;
} RIAIDPoint__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "x",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDPoint_FieldNumber_X,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RIAIDPoint__storage_, x),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "y",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDPoint_FieldNumber_Y,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RIAIDPoint__storage_, y),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RIAIDPoint class]
                                     rootClass:[RIAIDRiaidRoot class]
                                          file:RIAIDRiaidRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RIAIDPoint__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RIAIDLayout

@implementation RIAIDLayout

@dynamic priority;
@dynamic weight;
@dynamic hasMargin, margin;
@dynamic hasPadding, padding;
@dynamic width;
@dynamic height;
@dynamic hasMaxWidth, maxWidth;
@dynamic hasMaxHeight, maxHeight;

typedef struct RIAIDLayout__storage_ {
  uint32_t _has_storage_[1];
  int32_t priority;
  int32_t weight;
  float width;
  float height;
  RIAIDLayout_Edge *margin;
  RIAIDLayout_Edge *padding;
  RIAIDFloatValue *maxWidth;
  RIAIDFloatValue *maxHeight;
} RIAIDLayout__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "priority",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDLayout_FieldNumber_Priority,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RIAIDLayout__storage_, priority),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "weight",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDLayout_FieldNumber_Weight,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RIAIDLayout__storage_, weight),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "margin",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDLayout_Edge),
        .number = RIAIDLayout_FieldNumber_Margin,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RIAIDLayout__storage_, margin),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "padding",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDLayout_Edge),
        .number = RIAIDLayout_FieldNumber_Padding,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RIAIDLayout__storage_, padding),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "width",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDLayout_FieldNumber_Width,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(RIAIDLayout__storage_, width),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "height",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDLayout_FieldNumber_Height,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(RIAIDLayout__storage_, height),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "maxWidth",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDFloatValue),
        .number = RIAIDLayout_FieldNumber_MaxWidth,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(RIAIDLayout__storage_, maxWidth),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "maxHeight",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDFloatValue),
        .number = RIAIDLayout_FieldNumber_MaxHeight,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(RIAIDLayout__storage_, maxHeight),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RIAIDLayout class]
                                     rootClass:[RIAIDRiaidRoot class]
                                          file:RIAIDRiaidRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RIAIDLayout__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RIAIDLayout_Edge

@implementation RIAIDLayout_Edge

@dynamic start;
@dynamic end;
@dynamic top;
@dynamic bottom;

typedef struct RIAIDLayout_Edge__storage_ {
  uint32_t _has_storage_[1];
  float start;
  float end;
  float top;
  float bottom;
} RIAIDLayout_Edge__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "start",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDLayout_Edge_FieldNumber_Start,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RIAIDLayout_Edge__storage_, start),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "end",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDLayout_Edge_FieldNumber_End,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RIAIDLayout_Edge__storage_, end),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "top",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDLayout_Edge_FieldNumber_Top,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RIAIDLayout_Edge__storage_, top),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "bottom",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDLayout_Edge_FieldNumber_Bottom,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RIAIDLayout_Edge__storage_, bottom),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RIAIDLayout_Edge class]
                                     rootClass:[RIAIDRiaidRoot class]
                                          file:RIAIDRiaidRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RIAIDLayout_Edge__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(RIAIDLayout)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RIAIDCornerRadius

@implementation RIAIDCornerRadius

@dynamic topStart;
@dynamic bottomStart;
@dynamic topEnd;
@dynamic bottomEnd;

typedef struct RIAIDCornerRadius__storage_ {
  uint32_t _has_storage_[1];
  float topStart;
  float bottomStart;
  float topEnd;
  float bottomEnd;
} RIAIDCornerRadius__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "topStart",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDCornerRadius_FieldNumber_TopStart,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RIAIDCornerRadius__storage_, topStart),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "bottomStart",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDCornerRadius_FieldNumber_BottomStart,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RIAIDCornerRadius__storage_, bottomStart),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "topEnd",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDCornerRadius_FieldNumber_TopEnd,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RIAIDCornerRadius__storage_, topEnd),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "bottomEnd",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDCornerRadius_FieldNumber_BottomEnd,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RIAIDCornerRadius__storage_, bottomEnd),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RIAIDCornerRadius class]
                                     rootClass:[RIAIDRiaidRoot class]
                                          file:RIAIDRiaidRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RIAIDCornerRadius__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RIAIDGradient

@implementation RIAIDGradient

@dynamic type;
@dynamic angle;
@dynamic colorsArray, colorsArray_Count;

typedef struct RIAIDGradient__storage_ {
  uint32_t _has_storage_[1];
  RIAIDGradient_GradientType type;
  RIAIDGradient_GradientAngle angle;
  NSMutableArray *colorsArray;
} RIAIDGradient__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = RIAIDGradient_GradientType_EnumDescriptor,
        .number = RIAIDGradient_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RIAIDGradient__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "angle",
        .dataTypeSpecific.enumDescFunc = RIAIDGradient_GradientAngle_EnumDescriptor,
        .number = RIAIDGradient_FieldNumber_Angle,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RIAIDGradient__storage_, angle),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "colorsArray",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDGradient_FieldNumber_ColorsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RIAIDGradient__storage_, colorsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RIAIDGradient class]
                                     rootClass:[RIAIDRiaidRoot class]
                                          file:RIAIDRiaidRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RIAIDGradient__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RIAIDGradient_Type_RawValue(RIAIDGradient *message) {
  GPBDescriptor *descriptor = [RIAIDGradient descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RIAIDGradient_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetRIAIDGradient_Type_RawValue(RIAIDGradient *message, int32_t value) {
  GPBDescriptor *descriptor = [RIAIDGradient descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RIAIDGradient_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t RIAIDGradient_Angle_RawValue(RIAIDGradient *message) {
  GPBDescriptor *descriptor = [RIAIDGradient descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RIAIDGradient_FieldNumber_Angle];
  return GPBGetMessageInt32Field(message, field);
}

void SetRIAIDGradient_Angle_RawValue(RIAIDGradient *message, int32_t value) {
  GPBDescriptor *descriptor = [RIAIDGradient descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RIAIDGradient_FieldNumber_Angle];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum RIAIDGradient_GradientType

GPBEnumDescriptor *RIAIDGradient_GradientType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "GradientTypeUnknown\000GradientTypeLinear\000";
    static const int32_t values[] = {
        RIAIDGradient_GradientType_GradientTypeUnknown,
        RIAIDGradient_GradientType_GradientTypeLinear,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(RIAIDGradient_GradientType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:RIAIDGradient_GradientType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL RIAIDGradient_GradientType_IsValidValue(int32_t value__) {
  switch (value__) {
    case RIAIDGradient_GradientType_GradientTypeUnknown:
    case RIAIDGradient_GradientType_GradientTypeLinear:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum RIAIDGradient_GradientAngle

GPBEnumDescriptor *RIAIDGradient_GradientAngle_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "AngleUnknown\000Angle0\000Angle45\000Angle90\000Angl"
        "e135\000Angle180\000Angle225\000Angle270\000Angle315"
        "\000";
    static const int32_t values[] = {
        RIAIDGradient_GradientAngle_AngleUnknown,
        RIAIDGradient_GradientAngle_Angle0,
        RIAIDGradient_GradientAngle_Angle45,
        RIAIDGradient_GradientAngle_Angle90,
        RIAIDGradient_GradientAngle_Angle135,
        RIAIDGradient_GradientAngle_Angle180,
        RIAIDGradient_GradientAngle_Angle225,
        RIAIDGradient_GradientAngle_Angle270,
        RIAIDGradient_GradientAngle_Angle315,
    };
    static const char *extraTextFormatInfo = "\010\001e\201\000\002e\202\000\003e\202\000\004e\203\000\005e\203\000\006e\203\000\007e\203\000\010e\203\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(RIAIDGradient_GradientAngle)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:RIAIDGradient_GradientAngle_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL RIAIDGradient_GradientAngle_IsValidValue(int32_t value__) {
  switch (value__) {
    case RIAIDGradient_GradientAngle_AngleUnknown:
    case RIAIDGradient_GradientAngle_Angle0:
    case RIAIDGradient_GradientAngle_Angle45:
    case RIAIDGradient_GradientAngle_Angle90:
    case RIAIDGradient_GradientAngle_Angle135:
    case RIAIDGradient_GradientAngle_Angle180:
    case RIAIDGradient_GradientAngle_Angle225:
    case RIAIDGradient_GradientAngle_Angle270:
    case RIAIDGradient_GradientAngle_Angle315:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - RIAIDStroke

@implementation RIAIDStroke

@dynamic width;
@dynamic color;
@dynamic dashWidth;
@dynamic dashGap;

typedef struct RIAIDStroke__storage_ {
  uint32_t _has_storage_[1];
  float width;
  float dashWidth;
  float dashGap;
  NSString *color;
} RIAIDStroke__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "width",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDStroke_FieldNumber_Width,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RIAIDStroke__storage_, width),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "color",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDStroke_FieldNumber_Color,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RIAIDStroke__storage_, color),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "dashWidth",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDStroke_FieldNumber_DashWidth,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RIAIDStroke__storage_, dashWidth),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "dashGap",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDStroke_FieldNumber_DashGap,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RIAIDStroke__storage_, dashGap),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RIAIDStroke class]
                                     rootClass:[RIAIDRiaidRoot class]
                                          file:RIAIDRiaidRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RIAIDStroke__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RIAIDShadow

@implementation RIAIDShadow

@dynamic offsetX;
@dynamic offsetY;
@dynamic color;
@dynamic radius;

typedef struct RIAIDShadow__storage_ {
  uint32_t _has_storage_[1];
  float offsetX;
  float offsetY;
  float radius;
  NSString *color;
} RIAIDShadow__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "offsetX",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDShadow_FieldNumber_OffsetX,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RIAIDShadow__storage_, offsetX),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "offsetY",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDShadow_FieldNumber_OffsetY,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RIAIDShadow__storage_, offsetY),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "color",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDShadow_FieldNumber_Color,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RIAIDShadow__storage_, color),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "radius",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDShadow_FieldNumber_Radius,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RIAIDShadow__storage_, radius),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RIAIDShadow class]
                                     rootClass:[RIAIDRiaidRoot class]
                                          file:RIAIDRiaidRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RIAIDShadow__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RIAIDTextAttributes

@implementation RIAIDTextAttributes

@dynamic text;
@dynamic hasFontSize, fontSize;
@dynamic fontName;
@dynamic fontColor;
@dynamic hasMaxLines, maxLines;
@dynamic ellipsize;
@dynamic hasAlign, align;
@dynamic hasBold, bold;
@dynamic hasTilt, tilt;
@dynamic lineMode;
@dynamic hasLineSpace, lineSpace;
@dynamic highlightColor;
@dynamic richListArray, richListArray_Count;
@dynamic hasLineHeight, lineHeight;

typedef struct RIAIDTextAttributes__storage_ {
  uint32_t _has_storage_[1];
  RIAIDTextAttributes_Ellipsize ellipsize;
  RIAIDTextAttributes_LineMode lineMode;
  NSString *text;
  RIAIDFloatValue *fontSize;
  NSString *fontName;
  NSString *fontColor;
  RIAIDInt32Value *maxLines;
  RIAIDTextAttributes_Align *align;
  RIAIDBoolValue *bold;
  RIAIDBoolValue *tilt;
  RIAIDFloatValue *lineSpace;
  NSString *highlightColor;
  NSMutableArray *richListArray;
  RIAIDFloatValue *lineHeight;
} RIAIDTextAttributes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "text",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDTextAttributes_FieldNumber_Text,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RIAIDTextAttributes__storage_, text),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "fontSize",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDFloatValue),
        .number = RIAIDTextAttributes_FieldNumber_FontSize,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RIAIDTextAttributes__storage_, fontSize),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "fontName",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDTextAttributes_FieldNumber_FontName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RIAIDTextAttributes__storage_, fontName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "fontColor",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDTextAttributes_FieldNumber_FontColor,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RIAIDTextAttributes__storage_, fontColor),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "maxLines",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDInt32Value),
        .number = RIAIDTextAttributes_FieldNumber_MaxLines,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(RIAIDTextAttributes__storage_, maxLines),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "ellipsize",
        .dataTypeSpecific.enumDescFunc = RIAIDTextAttributes_Ellipsize_EnumDescriptor,
        .number = RIAIDTextAttributes_FieldNumber_Ellipsize,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(RIAIDTextAttributes__storage_, ellipsize),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "align",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDTextAttributes_Align),
        .number = RIAIDTextAttributes_FieldNumber_Align,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(RIAIDTextAttributes__storage_, align),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "bold",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDBoolValue),
        .number = RIAIDTextAttributes_FieldNumber_Bold,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(RIAIDTextAttributes__storage_, bold),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "tilt",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDBoolValue),
        .number = RIAIDTextAttributes_FieldNumber_Tilt,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(RIAIDTextAttributes__storage_, tilt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "lineMode",
        .dataTypeSpecific.enumDescFunc = RIAIDTextAttributes_LineMode_EnumDescriptor,
        .number = RIAIDTextAttributes_FieldNumber_LineMode,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(RIAIDTextAttributes__storage_, lineMode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "lineSpace",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDFloatValue),
        .number = RIAIDTextAttributes_FieldNumber_LineSpace,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(RIAIDTextAttributes__storage_, lineSpace),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "highlightColor",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDTextAttributes_FieldNumber_HighlightColor,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(RIAIDTextAttributes__storage_, highlightColor),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "richListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDTextAttributes_RichText),
        .number = RIAIDTextAttributes_FieldNumber_RichListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RIAIDTextAttributes__storage_, richListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "lineHeight",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDFloatValue),
        .number = RIAIDTextAttributes_FieldNumber_LineHeight,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(RIAIDTextAttributes__storage_, lineHeight),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RIAIDTextAttributes class]
                                     rootClass:[RIAIDRiaidRoot class]
                                          file:RIAIDRiaidRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RIAIDTextAttributes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RIAIDTextAttributes_Ellipsize_RawValue(RIAIDTextAttributes *message) {
  GPBDescriptor *descriptor = [RIAIDTextAttributes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RIAIDTextAttributes_FieldNumber_Ellipsize];
  return GPBGetMessageInt32Field(message, field);
}

void SetRIAIDTextAttributes_Ellipsize_RawValue(RIAIDTextAttributes *message, int32_t value) {
  GPBDescriptor *descriptor = [RIAIDTextAttributes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RIAIDTextAttributes_FieldNumber_Ellipsize];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t RIAIDTextAttributes_LineMode_RawValue(RIAIDTextAttributes *message) {
  GPBDescriptor *descriptor = [RIAIDTextAttributes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RIAIDTextAttributes_FieldNumber_LineMode];
  return GPBGetMessageInt32Field(message, field);
}

void SetRIAIDTextAttributes_LineMode_RawValue(RIAIDTextAttributes *message, int32_t value) {
  GPBDescriptor *descriptor = [RIAIDTextAttributes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RIAIDTextAttributes_FieldNumber_LineMode];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum RIAIDTextAttributes_Ellipsize

GPBEnumDescriptor *RIAIDTextAttributes_Ellipsize_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "EllipsizeUnknown\000EllipsizeStart\000Ellipsiz"
        "eMiddle\000EllipsizeEnd\000";
    static const int32_t values[] = {
        RIAIDTextAttributes_Ellipsize_EllipsizeUnknown,
        RIAIDTextAttributes_Ellipsize_EllipsizeStart,
        RIAIDTextAttributes_Ellipsize_EllipsizeMiddle,
        RIAIDTextAttributes_Ellipsize_EllipsizeEnd,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(RIAIDTextAttributes_Ellipsize)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:RIAIDTextAttributes_Ellipsize_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL RIAIDTextAttributes_Ellipsize_IsValidValue(int32_t value__) {
  switch (value__) {
    case RIAIDTextAttributes_Ellipsize_EllipsizeUnknown:
    case RIAIDTextAttributes_Ellipsize_EllipsizeStart:
    case RIAIDTextAttributes_Ellipsize_EllipsizeMiddle:
    case RIAIDTextAttributes_Ellipsize_EllipsizeEnd:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum RIAIDTextAttributes_LineMode

GPBEnumDescriptor *RIAIDTextAttributes_LineMode_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "LineModeUnknown\000LineModeNormal\000LineModeU"
        "nderline\000LineModeStrikeThru\000";
    static const int32_t values[] = {
        RIAIDTextAttributes_LineMode_LineModeUnknown,
        RIAIDTextAttributes_LineMode_LineModeNormal,
        RIAIDTextAttributes_LineMode_LineModeUnderline,
        RIAIDTextAttributes_LineMode_LineModeStrikeThru,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(RIAIDTextAttributes_LineMode)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:RIAIDTextAttributes_LineMode_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL RIAIDTextAttributes_LineMode_IsValidValue(int32_t value__) {
  switch (value__) {
    case RIAIDTextAttributes_LineMode_LineModeUnknown:
    case RIAIDTextAttributes_LineMode_LineModeNormal:
    case RIAIDTextAttributes_LineMode_LineModeUnderline:
    case RIAIDTextAttributes_LineMode_LineModeStrikeThru:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - RIAIDTextAttributes_Align

@implementation RIAIDTextAttributes_Align

@dynamic horizontal;
@dynamic vertical;

typedef struct RIAIDTextAttributes_Align__storage_ {
  uint32_t _has_storage_[1];
  RIAIDTextAttributes_Align_Horizontal horizontal;
  RIAIDTextAttributes_Align_Vertical vertical;
} RIAIDTextAttributes_Align__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "horizontal",
        .dataTypeSpecific.enumDescFunc = RIAIDTextAttributes_Align_Horizontal_EnumDescriptor,
        .number = RIAIDTextAttributes_Align_FieldNumber_Horizontal,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RIAIDTextAttributes_Align__storage_, horizontal),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "vertical",
        .dataTypeSpecific.enumDescFunc = RIAIDTextAttributes_Align_Vertical_EnumDescriptor,
        .number = RIAIDTextAttributes_Align_FieldNumber_Vertical,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RIAIDTextAttributes_Align__storage_, vertical),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RIAIDTextAttributes_Align class]
                                     rootClass:[RIAIDRiaidRoot class]
                                          file:RIAIDRiaidRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RIAIDTextAttributes_Align__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(RIAIDTextAttributes)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RIAIDTextAttributes_Align_Horizontal_RawValue(RIAIDTextAttributes_Align *message) {
  GPBDescriptor *descriptor = [RIAIDTextAttributes_Align descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RIAIDTextAttributes_Align_FieldNumber_Horizontal];
  return GPBGetMessageInt32Field(message, field);
}

void SetRIAIDTextAttributes_Align_Horizontal_RawValue(RIAIDTextAttributes_Align *message, int32_t value) {
  GPBDescriptor *descriptor = [RIAIDTextAttributes_Align descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RIAIDTextAttributes_Align_FieldNumber_Horizontal];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t RIAIDTextAttributes_Align_Vertical_RawValue(RIAIDTextAttributes_Align *message) {
  GPBDescriptor *descriptor = [RIAIDTextAttributes_Align descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RIAIDTextAttributes_Align_FieldNumber_Vertical];
  return GPBGetMessageInt32Field(message, field);
}

void SetRIAIDTextAttributes_Align_Vertical_RawValue(RIAIDTextAttributes_Align *message, int32_t value) {
  GPBDescriptor *descriptor = [RIAIDTextAttributes_Align descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RIAIDTextAttributes_Align_FieldNumber_Vertical];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum RIAIDTextAttributes_Align_Horizontal

GPBEnumDescriptor *RIAIDTextAttributes_Align_Horizontal_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "HorizontalUnknown\000HorizontalStart\000Horizo"
        "ntalCenter\000HorizontalEnd\000";
    static const int32_t values[] = {
        RIAIDTextAttributes_Align_Horizontal_HorizontalUnknown,
        RIAIDTextAttributes_Align_Horizontal_HorizontalStart,
        RIAIDTextAttributes_Align_Horizontal_HorizontalCenter,
        RIAIDTextAttributes_Align_Horizontal_HorizontalEnd,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(RIAIDTextAttributes_Align_Horizontal)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:RIAIDTextAttributes_Align_Horizontal_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL RIAIDTextAttributes_Align_Horizontal_IsValidValue(int32_t value__) {
  switch (value__) {
    case RIAIDTextAttributes_Align_Horizontal_HorizontalUnknown:
    case RIAIDTextAttributes_Align_Horizontal_HorizontalStart:
    case RIAIDTextAttributes_Align_Horizontal_HorizontalCenter:
    case RIAIDTextAttributes_Align_Horizontal_HorizontalEnd:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum RIAIDTextAttributes_Align_Vertical

GPBEnumDescriptor *RIAIDTextAttributes_Align_Vertical_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "VerticalUnknown\000VerticalTop\000VerticalCent"
        "er\000VerticalBottom\000";
    static const int32_t values[] = {
        RIAIDTextAttributes_Align_Vertical_VerticalUnknown,
        RIAIDTextAttributes_Align_Vertical_VerticalTop,
        RIAIDTextAttributes_Align_Vertical_VerticalCenter,
        RIAIDTextAttributes_Align_Vertical_VerticalBottom,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(RIAIDTextAttributes_Align_Vertical)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:RIAIDTextAttributes_Align_Vertical_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL RIAIDTextAttributes_Align_Vertical_IsValidValue(int32_t value__) {
  switch (value__) {
    case RIAIDTextAttributes_Align_Vertical_VerticalUnknown:
    case RIAIDTextAttributes_Align_Vertical_VerticalTop:
    case RIAIDTextAttributes_Align_Vertical_VerticalCenter:
    case RIAIDTextAttributes_Align_Vertical_VerticalBottom:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - RIAIDTextAttributes_RichText

@implementation RIAIDTextAttributes_RichText

@dynamic placeHolder;
@dynamic hasContent, content;
@dynamic hasHandler, handler;
@dynamic richAlign;

typedef struct RIAIDTextAttributes_RichText__storage_ {
  uint32_t _has_storage_[1];
  RIAIDTextAttributes_RichText_RichAlign richAlign;
  NSString *placeHolder;
  RIAIDNode *content;
  RIAIDHandler *handler;
} RIAIDTextAttributes_RichText__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "placeHolder",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDTextAttributes_RichText_FieldNumber_PlaceHolder,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RIAIDTextAttributes_RichText__storage_, placeHolder),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "content",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDNode),
        .number = RIAIDTextAttributes_RichText_FieldNumber_Content,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RIAIDTextAttributes_RichText__storage_, content),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "handler",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDHandler),
        .number = RIAIDTextAttributes_RichText_FieldNumber_Handler,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RIAIDTextAttributes_RichText__storage_, handler),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "richAlign",
        .dataTypeSpecific.enumDescFunc = RIAIDTextAttributes_RichText_RichAlign_EnumDescriptor,
        .number = RIAIDTextAttributes_RichText_FieldNumber_RichAlign,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RIAIDTextAttributes_RichText__storage_, richAlign),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RIAIDTextAttributes_RichText class]
                                     rootClass:[RIAIDRiaidRoot class]
                                          file:RIAIDRiaidRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RIAIDTextAttributes_RichText__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(RIAIDTextAttributes)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RIAIDTextAttributes_RichText_RichAlign_RawValue(RIAIDTextAttributes_RichText *message) {
  GPBDescriptor *descriptor = [RIAIDTextAttributes_RichText descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RIAIDTextAttributes_RichText_FieldNumber_RichAlign];
  return GPBGetMessageInt32Field(message, field);
}

void SetRIAIDTextAttributes_RichText_RichAlign_RawValue(RIAIDTextAttributes_RichText *message, int32_t value) {
  GPBDescriptor *descriptor = [RIAIDTextAttributes_RichText descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RIAIDTextAttributes_RichText_FieldNumber_RichAlign];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum RIAIDTextAttributes_RichText_RichAlign

GPBEnumDescriptor *RIAIDTextAttributes_RichText_RichAlign_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "RichAlignUnknown\000RichAlignCenter\000RichAli"
        "gnBottom\000";
    static const int32_t values[] = {
        RIAIDTextAttributes_RichText_RichAlign_RichAlignUnknown,
        RIAIDTextAttributes_RichText_RichAlign_RichAlignCenter,
        RIAIDTextAttributes_RichText_RichAlign_RichAlignBottom,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(RIAIDTextAttributes_RichText_RichAlign)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:RIAIDTextAttributes_RichText_RichAlign_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL RIAIDTextAttributes_RichText_RichAlign_IsValidValue(int32_t value__) {
  switch (value__) {
    case RIAIDTextAttributes_RichText_RichAlign_RichAlignUnknown:
    case RIAIDTextAttributes_RichText_RichAlign_RichAlignCenter:
    case RIAIDTextAttributes_RichText_RichAlign_RichAlignBottom:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - RIAIDImageAttributes

@implementation RIAIDImageAttributes

@dynamic URL;
@dynamic highlightURL;
@dynamic scaleType;
@dynamic rtlURL;
@dynamic rtlHighlightURL;
@dynamic colorFilter;

typedef struct RIAIDImageAttributes__storage_ {
  uint32_t _has_storage_[1];
  RIAIDImageAttributes_ScaleType scaleType;
  NSString *URL;
  NSString *highlightURL;
  NSString *rtlURL;
  NSString *rtlHighlightURL;
  NSString *colorFilter;
} RIAIDImageAttributes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDImageAttributes_FieldNumber_URL,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RIAIDImageAttributes__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "highlightURL",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDImageAttributes_FieldNumber_HighlightURL,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RIAIDImageAttributes__storage_, highlightURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "scaleType",
        .dataTypeSpecific.enumDescFunc = RIAIDImageAttributes_ScaleType_EnumDescriptor,
        .number = RIAIDImageAttributes_FieldNumber_ScaleType,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RIAIDImageAttributes__storage_, scaleType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "rtlURL",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDImageAttributes_FieldNumber_RtlURL,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RIAIDImageAttributes__storage_, rtlURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "rtlHighlightURL",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDImageAttributes_FieldNumber_RtlHighlightURL,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(RIAIDImageAttributes__storage_, rtlHighlightURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "colorFilter",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDImageAttributes_FieldNumber_ColorFilter,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(RIAIDImageAttributes__storage_, colorFilter),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RIAIDImageAttributes class]
                                     rootClass:[RIAIDRiaidRoot class]
                                          file:RIAIDRiaidRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RIAIDImageAttributes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001!!!\000\002\t\241!!\000\004\003\241!!\000\005\003\251\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RIAIDImageAttributes_ScaleType_RawValue(RIAIDImageAttributes *message) {
  GPBDescriptor *descriptor = [RIAIDImageAttributes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RIAIDImageAttributes_FieldNumber_ScaleType];
  return GPBGetMessageInt32Field(message, field);
}

void SetRIAIDImageAttributes_ScaleType_RawValue(RIAIDImageAttributes *message, int32_t value) {
  GPBDescriptor *descriptor = [RIAIDImageAttributes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RIAIDImageAttributes_FieldNumber_ScaleType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum RIAIDImageAttributes_ScaleType

GPBEnumDescriptor *RIAIDImageAttributes_ScaleType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "ScaleTypeUnknown\000ScaleTypeFitXy\000ScaleTyp"
        "eFitEnd\000ScaleTypeFitStart\000ScaleTypeFitCe"
        "nter\000ScaleTypeCenter\000ScaleTypeCenterCrop"
        "\000";
    static const int32_t values[] = {
        RIAIDImageAttributes_ScaleType_ScaleTypeUnknown,
        RIAIDImageAttributes_ScaleType_ScaleTypeFitXy,
        RIAIDImageAttributes_ScaleType_ScaleTypeFitEnd,
        RIAIDImageAttributes_ScaleType_ScaleTypeFitStart,
        RIAIDImageAttributes_ScaleType_ScaleTypeFitCenter,
        RIAIDImageAttributes_ScaleType_ScaleTypeCenter,
        RIAIDImageAttributes_ScaleType_ScaleTypeCenterCrop,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(RIAIDImageAttributes_ScaleType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:RIAIDImageAttributes_ScaleType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL RIAIDImageAttributes_ScaleType_IsValidValue(int32_t value__) {
  switch (value__) {
    case RIAIDImageAttributes_ScaleType_ScaleTypeUnknown:
    case RIAIDImageAttributes_ScaleType_ScaleTypeFitXy:
    case RIAIDImageAttributes_ScaleType_ScaleTypeFitEnd:
    case RIAIDImageAttributes_ScaleType_ScaleTypeFitStart:
    case RIAIDImageAttributes_ScaleType_ScaleTypeFitCenter:
    case RIAIDImageAttributes_ScaleType_ScaleTypeCenter:
    case RIAIDImageAttributes_ScaleType_ScaleTypeCenterCrop:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - RIAIDLottieAttributes

@implementation RIAIDLottieAttributes

@dynamic URL;
@dynamic hasSpeed, speed;
@dynamic hasProgress, progress;
@dynamic hasRepeat, repeat;
@dynamic repeatMode;
@dynamic hasAutoPlay, autoPlay;
@dynamic replaceTextListArray, replaceTextListArray_Count;
@dynamic replaceImageListArray, replaceImageListArray_Count;
@dynamic scaleType;
@dynamic replaceImageSupportNet;
@dynamic replaceKeyPathColorListArray, replaceKeyPathColorListArray_Count;

typedef struct RIAIDLottieAttributes__storage_ {
  uint32_t _has_storage_[1];
  RIAIDLottieAttributes_RepeatMode repeatMode;
  RIAIDLottieAttributes_ScaleType scaleType;
  NSString *URL;
  RIAIDFloatValue *speed;
  RIAIDFloatValue *progress;
  RIAIDBoolValue *repeat;
  RIAIDBoolValue *autoPlay;
  NSMutableArray *replaceTextListArray;
  NSMutableArray *replaceImageListArray;
  NSMutableArray *replaceKeyPathColorListArray;
} RIAIDLottieAttributes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDLottieAttributes_FieldNumber_URL,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RIAIDLottieAttributes__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "speed",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDFloatValue),
        .number = RIAIDLottieAttributes_FieldNumber_Speed,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RIAIDLottieAttributes__storage_, speed),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "progress",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDFloatValue),
        .number = RIAIDLottieAttributes_FieldNumber_Progress,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RIAIDLottieAttributes__storage_, progress),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "repeat",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDBoolValue),
        .number = RIAIDLottieAttributes_FieldNumber_Repeat,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RIAIDLottieAttributes__storage_, repeat),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "repeatMode",
        .dataTypeSpecific.enumDescFunc = RIAIDLottieAttributes_RepeatMode_EnumDescriptor,
        .number = RIAIDLottieAttributes_FieldNumber_RepeatMode,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(RIAIDLottieAttributes__storage_, repeatMode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "autoPlay",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDBoolValue),
        .number = RIAIDLottieAttributes_FieldNumber_AutoPlay,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(RIAIDLottieAttributes__storage_, autoPlay),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "replaceTextListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDLottieAttributes_ReplaceText),
        .number = RIAIDLottieAttributes_FieldNumber_ReplaceTextListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RIAIDLottieAttributes__storage_, replaceTextListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "replaceImageListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDLottieAttributes_ReplaceImage),
        .number = RIAIDLottieAttributes_FieldNumber_ReplaceImageListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RIAIDLottieAttributes__storage_, replaceImageListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "scaleType",
        .dataTypeSpecific.enumDescFunc = RIAIDLottieAttributes_ScaleType_EnumDescriptor,
        .number = RIAIDLottieAttributes_FieldNumber_ScaleType,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(RIAIDLottieAttributes__storage_, scaleType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "replaceImageSupportNet",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDLottieAttributes_FieldNumber_ReplaceImageSupportNet,
        .hasIndex = 7,
        .offset = 8,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "replaceKeyPathColorListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDLottieAttributes_ReplaceKeyPathColor),
        .number = RIAIDLottieAttributes_FieldNumber_ReplaceKeyPathColorListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RIAIDLottieAttributes__storage_, replaceKeyPathColorListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RIAIDLottieAttributes class]
                                     rootClass:[RIAIDRiaidRoot class]
                                          file:RIAIDRiaidRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RIAIDLottieAttributes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001!!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RIAIDLottieAttributes_RepeatMode_RawValue(RIAIDLottieAttributes *message) {
  GPBDescriptor *descriptor = [RIAIDLottieAttributes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RIAIDLottieAttributes_FieldNumber_RepeatMode];
  return GPBGetMessageInt32Field(message, field);
}

void SetRIAIDLottieAttributes_RepeatMode_RawValue(RIAIDLottieAttributes *message, int32_t value) {
  GPBDescriptor *descriptor = [RIAIDLottieAttributes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RIAIDLottieAttributes_FieldNumber_RepeatMode];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t RIAIDLottieAttributes_ScaleType_RawValue(RIAIDLottieAttributes *message) {
  GPBDescriptor *descriptor = [RIAIDLottieAttributes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RIAIDLottieAttributes_FieldNumber_ScaleType];
  return GPBGetMessageInt32Field(message, field);
}

void SetRIAIDLottieAttributes_ScaleType_RawValue(RIAIDLottieAttributes *message, int32_t value) {
  GPBDescriptor *descriptor = [RIAIDLottieAttributes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RIAIDLottieAttributes_FieldNumber_ScaleType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum RIAIDLottieAttributes_ScaleType

GPBEnumDescriptor *RIAIDLottieAttributes_ScaleType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "ScaleTypeUnknown\000ScaleTypeFitXy\000ScaleTyp"
        "eFitEnd\000ScaleTypeFitStart\000ScaleTypeFitCe"
        "nter\000ScaleTypeCenter\000ScaleTypeCenterCrop"
        "\000";
    static const int32_t values[] = {
        RIAIDLottieAttributes_ScaleType_ScaleTypeUnknown,
        RIAIDLottieAttributes_ScaleType_ScaleTypeFitXy,
        RIAIDLottieAttributes_ScaleType_ScaleTypeFitEnd,
        RIAIDLottieAttributes_ScaleType_ScaleTypeFitStart,
        RIAIDLottieAttributes_ScaleType_ScaleTypeFitCenter,
        RIAIDLottieAttributes_ScaleType_ScaleTypeCenter,
        RIAIDLottieAttributes_ScaleType_ScaleTypeCenterCrop,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(RIAIDLottieAttributes_ScaleType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:RIAIDLottieAttributes_ScaleType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL RIAIDLottieAttributes_ScaleType_IsValidValue(int32_t value__) {
  switch (value__) {
    case RIAIDLottieAttributes_ScaleType_ScaleTypeUnknown:
    case RIAIDLottieAttributes_ScaleType_ScaleTypeFitXy:
    case RIAIDLottieAttributes_ScaleType_ScaleTypeFitEnd:
    case RIAIDLottieAttributes_ScaleType_ScaleTypeFitStart:
    case RIAIDLottieAttributes_ScaleType_ScaleTypeFitCenter:
    case RIAIDLottieAttributes_ScaleType_ScaleTypeCenter:
    case RIAIDLottieAttributes_ScaleType_ScaleTypeCenterCrop:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum RIAIDLottieAttributes_RepeatMode

GPBEnumDescriptor *RIAIDLottieAttributes_RepeatMode_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "RepeatModeUnknown\000RepeatModeRestart\000Repe"
        "atModeReverse\000";
    static const int32_t values[] = {
        RIAIDLottieAttributes_RepeatMode_RepeatModeUnknown,
        RIAIDLottieAttributes_RepeatMode_RepeatModeRestart,
        RIAIDLottieAttributes_RepeatMode_RepeatModeReverse,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(RIAIDLottieAttributes_RepeatMode)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:RIAIDLottieAttributes_RepeatMode_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL RIAIDLottieAttributes_RepeatMode_IsValidValue(int32_t value__) {
  switch (value__) {
    case RIAIDLottieAttributes_RepeatMode_RepeatModeUnknown:
    case RIAIDLottieAttributes_RepeatMode_RepeatModeRestart:
    case RIAIDLottieAttributes_RepeatMode_RepeatModeReverse:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - RIAIDLottieAttributes_ReplaceText

@implementation RIAIDLottieAttributes_ReplaceText

@dynamic placeHolder;
@dynamic realText;

typedef struct RIAIDLottieAttributes_ReplaceText__storage_ {
  uint32_t _has_storage_[1];
  NSString *placeHolder;
  NSString *realText;
} RIAIDLottieAttributes_ReplaceText__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "placeHolder",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDLottieAttributes_ReplaceText_FieldNumber_PlaceHolder,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RIAIDLottieAttributes_ReplaceText__storage_, placeHolder),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "realText",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDLottieAttributes_ReplaceText_FieldNumber_RealText,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RIAIDLottieAttributes_ReplaceText__storage_, realText),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RIAIDLottieAttributes_ReplaceText class]
                                     rootClass:[RIAIDRiaidRoot class]
                                          file:RIAIDRiaidRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RIAIDLottieAttributes_ReplaceText__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(RIAIDLottieAttributes)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RIAIDLottieAttributes_ReplaceImage

@implementation RIAIDLottieAttributes_ReplaceImage

@dynamic placeImageId;
@dynamic imageAddress;

typedef struct RIAIDLottieAttributes_ReplaceImage__storage_ {
  uint32_t _has_storage_[1];
  NSString *placeImageId;
  NSString *imageAddress;
} RIAIDLottieAttributes_ReplaceImage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "placeImageId",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDLottieAttributes_ReplaceImage_FieldNumber_PlaceImageId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RIAIDLottieAttributes_ReplaceImage__storage_, placeImageId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "imageAddress",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDLottieAttributes_ReplaceImage_FieldNumber_ImageAddress,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RIAIDLottieAttributes_ReplaceImage__storage_, imageAddress),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RIAIDLottieAttributes_ReplaceImage class]
                                     rootClass:[RIAIDRiaidRoot class]
                                          file:RIAIDRiaidRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RIAIDLottieAttributes_ReplaceImage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(RIAIDLottieAttributes)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RIAIDLottieAttributes_ReplaceKeyPathColor

@implementation RIAIDLottieAttributes_ReplaceKeyPathColor

@dynamic keyPathArray, keyPathArray_Count;
@dynamic color;

typedef struct RIAIDLottieAttributes_ReplaceKeyPathColor__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *keyPathArray;
  NSString *color;
} RIAIDLottieAttributes_ReplaceKeyPathColor__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "keyPathArray",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDLottieAttributes_ReplaceKeyPathColor_FieldNumber_KeyPathArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RIAIDLottieAttributes_ReplaceKeyPathColor__storage_, keyPathArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "color",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDLottieAttributes_ReplaceKeyPathColor_FieldNumber_Color,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RIAIDLottieAttributes_ReplaceKeyPathColor__storage_, color),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RIAIDLottieAttributes_ReplaceKeyPathColor class]
                                     rootClass:[RIAIDRiaidRoot class]
                                          file:RIAIDRiaidRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RIAIDLottieAttributes_ReplaceKeyPathColor__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(RIAIDLottieAttributes)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RIAIDScrollAttributes

@implementation RIAIDScrollAttributes

@dynamic hasShowScrollbar, showScrollbar;

typedef struct RIAIDScrollAttributes__storage_ {
  uint32_t _has_storage_[1];
  RIAIDBoolValue *showScrollbar;
} RIAIDScrollAttributes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "showScrollbar",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDBoolValue),
        .number = RIAIDScrollAttributes_FieldNumber_ShowScrollbar,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RIAIDScrollAttributes__storage_, showScrollbar),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RIAIDScrollAttributes class]
                                     rootClass:[RIAIDRiaidRoot class]
                                          file:RIAIDRiaidRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RIAIDScrollAttributes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RIAIDButtonAttributes

@implementation RIAIDButtonAttributes

@dynamic hasContent, content;
@dynamic highlightStateListArray, highlightStateListArray_Count;

typedef struct RIAIDButtonAttributes__storage_ {
  uint32_t _has_storage_[1];
  RIAIDNode *content;
  NSMutableArray *highlightStateListArray;
} RIAIDButtonAttributes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "content",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDNode),
        .number = RIAIDButtonAttributes_FieldNumber_Content,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RIAIDButtonAttributes__storage_, content),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "highlightStateListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDButtonAttributes_HighlightState),
        .number = RIAIDButtonAttributes_FieldNumber_HighlightStateListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RIAIDButtonAttributes__storage_, highlightStateListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RIAIDButtonAttributes class]
                                     rootClass:[RIAIDRiaidRoot class]
                                          file:RIAIDRiaidRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RIAIDButtonAttributes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RIAIDButtonAttributes_HighlightState

@implementation RIAIDButtonAttributes_HighlightState

@dynamic key;
@dynamic hasAttributes, attributes;

typedef struct RIAIDButtonAttributes_HighlightState__storage_ {
  uint32_t _has_storage_[1];
  int32_t key;
  RIAIDAttributes *attributes;
} RIAIDButtonAttributes_HighlightState__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "key",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDButtonAttributes_HighlightState_FieldNumber_Key,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RIAIDButtonAttributes_HighlightState__storage_, key),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "attributes",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDAttributes),
        .number = RIAIDButtonAttributes_HighlightState_FieldNumber_Attributes,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RIAIDButtonAttributes_HighlightState__storage_, attributes),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RIAIDButtonAttributes_HighlightState class]
                                     rootClass:[RIAIDRiaidRoot class]
                                          file:RIAIDRiaidRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RIAIDButtonAttributes_HighlightState__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(RIAIDButtonAttributes)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RIAIDVideoAttributes

@implementation RIAIDVideoAttributes

@dynamic hasAutoMute, autoMute;
@dynamic hasAutoLoop, autoLoop;
@dynamic autoSeekTime;
@dynamic hasAutoPlay, autoPlay;
@dynamic URL;
@dynamic coverURL;
@dynamic manifest;
@dynamic adapterType;
@dynamic hasOpaque, opaque;

typedef struct RIAIDVideoAttributes__storage_ {
  uint32_t _has_storage_[1];
  RIAIDVideoAttributes_AdapterType adapterType;
  RIAIDBoolValue *autoMute;
  RIAIDBoolValue *autoLoop;
  RIAIDBoolValue *autoPlay;
  NSString *URL;
  NSString *coverURL;
  NSString *manifest;
  RIAIDBoolValue *opaque;
  int64_t autoSeekTime;
} RIAIDVideoAttributes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "autoMute",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDBoolValue),
        .number = RIAIDVideoAttributes_FieldNumber_AutoMute,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RIAIDVideoAttributes__storage_, autoMute),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "autoLoop",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDBoolValue),
        .number = RIAIDVideoAttributes_FieldNumber_AutoLoop,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RIAIDVideoAttributes__storage_, autoLoop),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "autoSeekTime",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDVideoAttributes_FieldNumber_AutoSeekTime,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RIAIDVideoAttributes__storage_, autoSeekTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "autoPlay",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDBoolValue),
        .number = RIAIDVideoAttributes_FieldNumber_AutoPlay,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RIAIDVideoAttributes__storage_, autoPlay),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDVideoAttributes_FieldNumber_URL,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(RIAIDVideoAttributes__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "coverURL",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDVideoAttributes_FieldNumber_CoverURL,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(RIAIDVideoAttributes__storage_, coverURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "manifest",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDVideoAttributes_FieldNumber_Manifest,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(RIAIDVideoAttributes__storage_, manifest),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "adapterType",
        .dataTypeSpecific.enumDescFunc = RIAIDVideoAttributes_AdapterType_EnumDescriptor,
        .number = RIAIDVideoAttributes_FieldNumber_AdapterType,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(RIAIDVideoAttributes__storage_, adapterType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "opaque",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDBoolValue),
        .number = RIAIDVideoAttributes_FieldNumber_Opaque,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(RIAIDVideoAttributes__storage_, opaque),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RIAIDVideoAttributes class]
                                     rootClass:[RIAIDRiaidRoot class]
                                          file:RIAIDRiaidRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RIAIDVideoAttributes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\005!!!\000\006\005\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RIAIDVideoAttributes_AdapterType_RawValue(RIAIDVideoAttributes *message) {
  GPBDescriptor *descriptor = [RIAIDVideoAttributes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RIAIDVideoAttributes_FieldNumber_AdapterType];
  return GPBGetMessageInt32Field(message, field);
}

void SetRIAIDVideoAttributes_AdapterType_RawValue(RIAIDVideoAttributes *message, int32_t value) {
  GPBDescriptor *descriptor = [RIAIDVideoAttributes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RIAIDVideoAttributes_FieldNumber_AdapterType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum RIAIDVideoAttributes_AdapterType

GPBEnumDescriptor *RIAIDVideoAttributes_AdapterType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "AdapterTypeUnknown\000AdapterTypeCenterCrop"
        "\000AdapterTypeInspire\000AdapterTypeAuto\000";
    static const int32_t values[] = {
        RIAIDVideoAttributes_AdapterType_AdapterTypeUnknown,
        RIAIDVideoAttributes_AdapterType_AdapterTypeCenterCrop,
        RIAIDVideoAttributes_AdapterType_AdapterTypeInspire,
        RIAIDVideoAttributes_AdapterType_AdapterTypeAuto,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(RIAIDVideoAttributes_AdapterType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:RIAIDVideoAttributes_AdapterType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL RIAIDVideoAttributes_AdapterType_IsValidValue(int32_t value__) {
  switch (value__) {
    case RIAIDVideoAttributes_AdapterType_AdapterTypeUnknown:
    case RIAIDVideoAttributes_AdapterType_AdapterTypeCenterCrop:
    case RIAIDVideoAttributes_AdapterType_AdapterTypeInspire:
    case RIAIDVideoAttributes_AdapterType_AdapterTypeAuto:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - RIAIDAnchorGroupAttributes

@implementation RIAIDAnchorGroupAttributes

@dynamic itemsArray, itemsArray_Count;

typedef struct RIAIDAnchorGroupAttributes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *itemsArray;
} RIAIDAnchorGroupAttributes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "itemsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDAnchorGroupAttributes_AnchorItemAttributes),
        .number = RIAIDAnchorGroupAttributes_FieldNumber_ItemsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RIAIDAnchorGroupAttributes__storage_, itemsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RIAIDAnchorGroupAttributes class]
                                     rootClass:[RIAIDRiaidRoot class]
                                          file:RIAIDRiaidRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RIAIDAnchorGroupAttributes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RIAIDAnchorGroupAttributes_AnchorItemAttributes

@implementation RIAIDAnchorGroupAttributes_AnchorItemAttributes

@dynamic hasAnchorPoint, anchorPoint;
@dynamic anchorPointX;
@dynamic anchorPointY;
@dynamic hasAnchorInfo, anchorInfo;
@dynamic anchorInfoStartOffsetPointX;
@dynamic anchorInfoAlignOffsetPointY;
@dynamic anchorVerticalAlign;

typedef struct RIAIDAnchorGroupAttributes_AnchorItemAttributes__storage_ {
  uint32_t _has_storage_[1];
  int32_t anchorPointX;
  int32_t anchorPointY;
  float anchorInfoStartOffsetPointX;
  float anchorInfoAlignOffsetPointY;
  RIAIDAnchorGroupAttributes_AnchorItemAttributes_AnchorInfoVerticalAlign anchorVerticalAlign;
  RIAIDNode *anchorPoint;
  RIAIDNode *anchorInfo;
} RIAIDAnchorGroupAttributes_AnchorItemAttributes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "anchorPoint",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDNode),
        .number = RIAIDAnchorGroupAttributes_AnchorItemAttributes_FieldNumber_AnchorPoint,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RIAIDAnchorGroupAttributes_AnchorItemAttributes__storage_, anchorPoint),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "anchorPointX",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDAnchorGroupAttributes_AnchorItemAttributes_FieldNumber_AnchorPointX,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RIAIDAnchorGroupAttributes_AnchorItemAttributes__storage_, anchorPointX),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "anchorPointY",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDAnchorGroupAttributes_AnchorItemAttributes_FieldNumber_AnchorPointY,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RIAIDAnchorGroupAttributes_AnchorItemAttributes__storage_, anchorPointY),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "anchorInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDNode),
        .number = RIAIDAnchorGroupAttributes_AnchorItemAttributes_FieldNumber_AnchorInfo,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RIAIDAnchorGroupAttributes_AnchorItemAttributes__storage_, anchorInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "anchorInfoStartOffsetPointX",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDAnchorGroupAttributes_AnchorItemAttributes_FieldNumber_AnchorInfoStartOffsetPointX,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(RIAIDAnchorGroupAttributes_AnchorItemAttributes__storage_, anchorInfoStartOffsetPointX),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "anchorInfoAlignOffsetPointY",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDAnchorGroupAttributes_AnchorItemAttributes_FieldNumber_AnchorInfoAlignOffsetPointY,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(RIAIDAnchorGroupAttributes_AnchorItemAttributes__storage_, anchorInfoAlignOffsetPointY),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "anchorVerticalAlign",
        .dataTypeSpecific.enumDescFunc = RIAIDAnchorGroupAttributes_AnchorItemAttributes_AnchorInfoVerticalAlign_EnumDescriptor,
        .number = RIAIDAnchorGroupAttributes_AnchorItemAttributes_FieldNumber_AnchorVerticalAlign,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(RIAIDAnchorGroupAttributes_AnchorItemAttributes__storage_, anchorVerticalAlign),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RIAIDAnchorGroupAttributes_AnchorItemAttributes class]
                                     rootClass:[RIAIDRiaidRoot class]
                                          file:RIAIDRiaidRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RIAIDAnchorGroupAttributes_AnchorItemAttributes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(RIAIDAnchorGroupAttributes)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RIAIDAnchorGroupAttributes_AnchorItemAttributes_AnchorVerticalAlign_RawValue(RIAIDAnchorGroupAttributes_AnchorItemAttributes *message) {
  GPBDescriptor *descriptor = [RIAIDAnchorGroupAttributes_AnchorItemAttributes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RIAIDAnchorGroupAttributes_AnchorItemAttributes_FieldNumber_AnchorVerticalAlign];
  return GPBGetMessageInt32Field(message, field);
}

void SetRIAIDAnchorGroupAttributes_AnchorItemAttributes_AnchorVerticalAlign_RawValue(RIAIDAnchorGroupAttributes_AnchorItemAttributes *message, int32_t value) {
  GPBDescriptor *descriptor = [RIAIDAnchorGroupAttributes_AnchorItemAttributes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RIAIDAnchorGroupAttributes_AnchorItemAttributes_FieldNumber_AnchorVerticalAlign];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum RIAIDAnchorGroupAttributes_AnchorItemAttributes_AnchorInfoVerticalAlign

GPBEnumDescriptor *RIAIDAnchorGroupAttributes_AnchorItemAttributes_AnchorInfoVerticalAlign_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "AnchorVerticalUnknown\000AnchorVerticalTop\000"
        "AnchorVerticalCenter\000AnchorVerticalBotto"
        "m\000";
    static const int32_t values[] = {
        RIAIDAnchorGroupAttributes_AnchorItemAttributes_AnchorInfoVerticalAlign_AnchorVerticalUnknown,
        RIAIDAnchorGroupAttributes_AnchorItemAttributes_AnchorInfoVerticalAlign_AnchorVerticalTop,
        RIAIDAnchorGroupAttributes_AnchorItemAttributes_AnchorInfoVerticalAlign_AnchorVerticalCenter,
        RIAIDAnchorGroupAttributes_AnchorItemAttributes_AnchorInfoVerticalAlign_AnchorVerticalBottom,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(RIAIDAnchorGroupAttributes_AnchorItemAttributes_AnchorInfoVerticalAlign)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:RIAIDAnchorGroupAttributes_AnchorItemAttributes_AnchorInfoVerticalAlign_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL RIAIDAnchorGroupAttributes_AnchorItemAttributes_AnchorInfoVerticalAlign_IsValidValue(int32_t value__) {
  switch (value__) {
    case RIAIDAnchorGroupAttributes_AnchorItemAttributes_AnchorInfoVerticalAlign_AnchorVerticalUnknown:
    case RIAIDAnchorGroupAttributes_AnchorItemAttributes_AnchorInfoVerticalAlign_AnchorVerticalTop:
    case RIAIDAnchorGroupAttributes_AnchorItemAttributes_AnchorInfoVerticalAlign_AnchorVerticalCenter:
    case RIAIDAnchorGroupAttributes_AnchorItemAttributes_AnchorInfoVerticalAlign_AnchorVerticalBottom:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - RIAIDCommonAttributes

@implementation RIAIDCommonAttributes

@dynamic shapeType;
@dynamic hasCornerRadius, cornerRadius;
@dynamic backgroundColor;
@dynamic hasGradient, gradient;
@dynamic hasStroke, stroke;
@dynamic hasShadow, shadow;
@dynamic hasAlpha, alpha;
@dynamic hasHidden, hidden;

typedef struct RIAIDCommonAttributes__storage_ {
  uint32_t _has_storage_[1];
  RIAIDCommonAttributes_ShapeType shapeType;
  RIAIDCornerRadius *cornerRadius;
  NSString *backgroundColor;
  RIAIDGradient *gradient;
  RIAIDStroke *stroke;
  RIAIDShadow *shadow;
  RIAIDFloatValue *alpha;
  RIAIDBoolValue *hidden;
} RIAIDCommonAttributes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "shapeType",
        .dataTypeSpecific.enumDescFunc = RIAIDCommonAttributes_ShapeType_EnumDescriptor,
        .number = RIAIDCommonAttributes_FieldNumber_ShapeType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RIAIDCommonAttributes__storage_, shapeType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "cornerRadius",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDCornerRadius),
        .number = RIAIDCommonAttributes_FieldNumber_CornerRadius,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RIAIDCommonAttributes__storage_, cornerRadius),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "backgroundColor",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDCommonAttributes_FieldNumber_BackgroundColor,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RIAIDCommonAttributes__storage_, backgroundColor),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "gradient",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDGradient),
        .number = RIAIDCommonAttributes_FieldNumber_Gradient,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RIAIDCommonAttributes__storage_, gradient),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "stroke",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDStroke),
        .number = RIAIDCommonAttributes_FieldNumber_Stroke,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(RIAIDCommonAttributes__storage_, stroke),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "shadow",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDShadow),
        .number = RIAIDCommonAttributes_FieldNumber_Shadow,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(RIAIDCommonAttributes__storage_, shadow),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "alpha",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDFloatValue),
        .number = RIAIDCommonAttributes_FieldNumber_Alpha,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(RIAIDCommonAttributes__storage_, alpha),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "hidden",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDBoolValue),
        .number = RIAIDCommonAttributes_FieldNumber_Hidden,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(RIAIDCommonAttributes__storage_, hidden),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RIAIDCommonAttributes class]
                                     rootClass:[RIAIDRiaidRoot class]
                                          file:RIAIDRiaidRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RIAIDCommonAttributes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RIAIDCommonAttributes_ShapeType_RawValue(RIAIDCommonAttributes *message) {
  GPBDescriptor *descriptor = [RIAIDCommonAttributes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RIAIDCommonAttributes_FieldNumber_ShapeType];
  return GPBGetMessageInt32Field(message, field);
}

void SetRIAIDCommonAttributes_ShapeType_RawValue(RIAIDCommonAttributes *message, int32_t value) {
  GPBDescriptor *descriptor = [RIAIDCommonAttributes descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RIAIDCommonAttributes_FieldNumber_ShapeType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum RIAIDCommonAttributes_ShapeType

GPBEnumDescriptor *RIAIDCommonAttributes_ShapeType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "ShapeTypeUnknown\000ShapeTypeRectangle\000";
    static const int32_t values[] = {
        RIAIDCommonAttributes_ShapeType_ShapeTypeUnknown,
        RIAIDCommonAttributes_ShapeType_ShapeTypeRectangle,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(RIAIDCommonAttributes_ShapeType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:RIAIDCommonAttributes_ShapeType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL RIAIDCommonAttributes_ShapeType_IsValidValue(int32_t value__) {
  switch (value__) {
    case RIAIDCommonAttributes_ShapeType_ShapeTypeUnknown:
    case RIAIDCommonAttributes_ShapeType_ShapeTypeRectangle:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - RIAIDResponder

@implementation RIAIDResponder

@dynamic triggerKeysArray, triggerKeysArray_Count;

typedef struct RIAIDResponder__storage_ {
  uint32_t _has_storage_[1];
  GPBInt32Array *triggerKeysArray;
} RIAIDResponder__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "triggerKeysArray",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDResponder_FieldNumber_TriggerKeysArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RIAIDResponder__storage_, triggerKeysArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RIAIDResponder class]
                                     rootClass:[RIAIDRiaidRoot class]
                                          file:RIAIDRiaidRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RIAIDResponder__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RIAIDHandler

@implementation RIAIDHandler

@dynamic hasClick, click;
@dynamic hasDoubleClick, doubleClick;
@dynamic hasLongPress, longPress;

typedef struct RIAIDHandler__storage_ {
  uint32_t _has_storage_[1];
  RIAIDResponder *click;
  RIAIDResponder *doubleClick;
  RIAIDResponder *longPress;
} RIAIDHandler__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "click",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDResponder),
        .number = RIAIDHandler_FieldNumber_Click,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RIAIDHandler__storage_, click),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "doubleClick",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDResponder),
        .number = RIAIDHandler_FieldNumber_DoubleClick,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RIAIDHandler__storage_, doubleClick),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "longPress",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDResponder),
        .number = RIAIDHandler_FieldNumber_LongPress,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RIAIDHandler__storage_, longPress),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RIAIDHandler class]
                                     rootClass:[RIAIDRiaidRoot class]
                                          file:RIAIDRiaidRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RIAIDHandler__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RIAIDGestureModel

@implementation RIAIDGestureModel

@dynamic hasSwipe, swipe;

typedef struct RIAIDGestureModel__storage_ {
  uint32_t _has_storage_[1];
  RIAIDSwipeGesture *swipe;
} RIAIDGestureModel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "swipe",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDSwipeGesture),
        .number = RIAIDGestureModel_FieldNumber_Swipe,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RIAIDGestureModel__storage_, swipe),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RIAIDGestureModel class]
                                     rootClass:[RIAIDRiaidRoot class]
                                          file:RIAIDRiaidRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RIAIDGestureModel__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RIAIDSwipeGesture

@implementation RIAIDSwipeGesture

@dynamic triggerKeysArray, triggerKeysArray_Count;
@dynamic direction;

typedef struct RIAIDSwipeGesture__storage_ {
  uint32_t _has_storage_[1];
  RIAIDSwipeGesture_GestureSwipeDirection direction;
  GPBInt32Array *triggerKeysArray;
} RIAIDSwipeGesture__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "triggerKeysArray",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDSwipeGesture_FieldNumber_TriggerKeysArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RIAIDSwipeGesture__storage_, triggerKeysArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "direction",
        .dataTypeSpecific.enumDescFunc = RIAIDSwipeGesture_GestureSwipeDirection_EnumDescriptor,
        .number = RIAIDSwipeGesture_FieldNumber_Direction,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RIAIDSwipeGesture__storage_, direction),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RIAIDSwipeGesture class]
                                     rootClass:[RIAIDRiaidRoot class]
                                          file:RIAIDRiaidRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RIAIDSwipeGesture__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RIAIDSwipeGesture_Direction_RawValue(RIAIDSwipeGesture *message) {
  GPBDescriptor *descriptor = [RIAIDSwipeGesture descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RIAIDSwipeGesture_FieldNumber_Direction];
  return GPBGetMessageInt32Field(message, field);
}

void SetRIAIDSwipeGesture_Direction_RawValue(RIAIDSwipeGesture *message, int32_t value) {
  GPBDescriptor *descriptor = [RIAIDSwipeGesture descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RIAIDSwipeGesture_FieldNumber_Direction];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum RIAIDSwipeGesture_GestureSwipeDirection

GPBEnumDescriptor *RIAIDSwipeGesture_GestureSwipeDirection_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "SwipeDirectionNone\000SwipeDirectionRight\000S"
        "wipeDirectionLeft\000SwipeDirectionUp\000Swipe"
        "DirectionDown\000";
    static const int32_t values[] = {
        RIAIDSwipeGesture_GestureSwipeDirection_SwipeDirectionNone,
        RIAIDSwipeGesture_GestureSwipeDirection_SwipeDirectionRight,
        RIAIDSwipeGesture_GestureSwipeDirection_SwipeDirectionLeft,
        RIAIDSwipeGesture_GestureSwipeDirection_SwipeDirectionUp,
        RIAIDSwipeGesture_GestureSwipeDirection_SwipeDirectionDown,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(RIAIDSwipeGesture_GestureSwipeDirection)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:RIAIDSwipeGesture_GestureSwipeDirection_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL RIAIDSwipeGesture_GestureSwipeDirection_IsValidValue(int32_t value__) {
  switch (value__) {
    case RIAIDSwipeGesture_GestureSwipeDirection_SwipeDirectionNone:
    case RIAIDSwipeGesture_GestureSwipeDirection_SwipeDirectionRight:
    case RIAIDSwipeGesture_GestureSwipeDirection_SwipeDirectionLeft:
    case RIAIDSwipeGesture_GestureSwipeDirection_SwipeDirectionUp:
    case RIAIDSwipeGesture_GestureSwipeDirection_SwipeDirectionDown:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - RIAIDVideoHandler

@implementation RIAIDVideoHandler

@dynamic hasImpression, impression;
@dynamic hasFinish, finish;
@dynamic hasPause, pause;
@dynamic hasStart, start;
@dynamic hasResume, resume;

typedef struct RIAIDVideoHandler__storage_ {
  uint32_t _has_storage_[1];
  RIAIDResponder *impression;
  RIAIDResponder *finish;
  RIAIDResponder *pause;
  RIAIDResponder *start;
  RIAIDResponder *resume;
} RIAIDVideoHandler__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "impression",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDResponder),
        .number = RIAIDVideoHandler_FieldNumber_Impression,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RIAIDVideoHandler__storage_, impression),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "finish",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDResponder),
        .number = RIAIDVideoHandler_FieldNumber_Finish,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RIAIDVideoHandler__storage_, finish),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "pause",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDResponder),
        .number = RIAIDVideoHandler_FieldNumber_Pause,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RIAIDVideoHandler__storage_, pause),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "start",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDResponder),
        .number = RIAIDVideoHandler_FieldNumber_Start,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RIAIDVideoHandler__storage_, start),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "resume",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDResponder),
        .number = RIAIDVideoHandler_FieldNumber_Resume,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(RIAIDVideoHandler__storage_, resume),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RIAIDVideoHandler class]
                                     rootClass:[RIAIDRiaidRoot class]
                                          file:RIAIDRiaidRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RIAIDVideoHandler__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RIAIDLottieHandler

@implementation RIAIDLottieHandler

@dynamic hasStart, start;
@dynamic hasEnd, end;
@dynamic hasReplaceImageSuccess, replaceImageSuccess;
@dynamic hasReplaceImageFalse, replaceImageFalse;

typedef struct RIAIDLottieHandler__storage_ {
  uint32_t _has_storage_[1];
  RIAIDResponder *start;
  RIAIDResponder *end;
  RIAIDResponder *replaceImageSuccess;
  RIAIDResponder *replaceImageFalse;
} RIAIDLottieHandler__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "start",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDResponder),
        .number = RIAIDLottieHandler_FieldNumber_Start,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RIAIDLottieHandler__storage_, start),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "end",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDResponder),
        .number = RIAIDLottieHandler_FieldNumber_End,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RIAIDLottieHandler__storage_, end),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "replaceImageSuccess",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDResponder),
        .number = RIAIDLottieHandler_FieldNumber_ReplaceImageSuccess,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RIAIDLottieHandler__storage_, replaceImageSuccess),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "replaceImageFalse",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDResponder),
        .number = RIAIDLottieHandler_FieldNumber_ReplaceImageFalse,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RIAIDLottieHandler__storage_, replaceImageFalse),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RIAIDLottieHandler class]
                                     rootClass:[RIAIDRiaidRoot class]
                                          file:RIAIDRiaidRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RIAIDLottieHandler__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RIAIDAttributes

@implementation RIAIDAttributes

@dynamic hasCommon, common;
@dynamic hasText, text;
@dynamic hasImage, image;
@dynamic hasLottie, lottie;
@dynamic hasScroll, scroll;
@dynamic hasButton, button;
@dynamic hasVideo, video;
@dynamic hasAnchorGroup, anchorGroup;

typedef struct RIAIDAttributes__storage_ {
  uint32_t _has_storage_[1];
  RIAIDCommonAttributes *common;
  RIAIDTextAttributes *text;
  RIAIDImageAttributes *image;
  RIAIDLottieAttributes *lottie;
  RIAIDScrollAttributes *scroll;
  RIAIDButtonAttributes *button;
  RIAIDVideoAttributes *video;
  RIAIDAnchorGroupAttributes *anchorGroup;
} RIAIDAttributes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "common",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDCommonAttributes),
        .number = RIAIDAttributes_FieldNumber_Common,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RIAIDAttributes__storage_, common),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "text",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDTextAttributes),
        .number = RIAIDAttributes_FieldNumber_Text,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RIAIDAttributes__storage_, text),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "image",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDImageAttributes),
        .number = RIAIDAttributes_FieldNumber_Image,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RIAIDAttributes__storage_, image),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "lottie",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDLottieAttributes),
        .number = RIAIDAttributes_FieldNumber_Lottie,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RIAIDAttributes__storage_, lottie),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "scroll",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDScrollAttributes),
        .number = RIAIDAttributes_FieldNumber_Scroll,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(RIAIDAttributes__storage_, scroll),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "button",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDButtonAttributes),
        .number = RIAIDAttributes_FieldNumber_Button,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(RIAIDAttributes__storage_, button),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "video",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDVideoAttributes),
        .number = RIAIDAttributes_FieldNumber_Video,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(RIAIDAttributes__storage_, video),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "anchorGroup",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDAnchorGroupAttributes),
        .number = RIAIDAttributes_FieldNumber_AnchorGroup,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(RIAIDAttributes__storage_, anchorGroup),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RIAIDAttributes class]
                                     rootClass:[RIAIDRiaidRoot class]
                                          file:RIAIDRiaidRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RIAIDAttributes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum RIAIDAttributes_AttributeType

GPBEnumDescriptor *RIAIDAttributes_AttributeType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "AttributeUnknown\000AttributeVideoPosition\000"
        "AttributeVideoTotalDuration\000";
    static const int32_t values[] = {
        RIAIDAttributes_AttributeType_AttributeUnknown,
        RIAIDAttributes_AttributeType_AttributeVideoPosition,
        RIAIDAttributes_AttributeType_AttributeVideoTotalDuration,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(RIAIDAttributes_AttributeType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:RIAIDAttributes_AttributeType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL RIAIDAttributes_AttributeType_IsValidValue(int32_t value__) {
  switch (value__) {
    case RIAIDAttributes_AttributeType_AttributeUnknown:
    case RIAIDAttributes_AttributeType_AttributeVideoPosition:
    case RIAIDAttributes_AttributeType_AttributeVideoTotalDuration:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - RIAIDNode

@implementation RIAIDNode

@dynamic classType;
@dynamic key;
@dynamic hasLayout, layout;
@dynamic hasHandler, handler;
@dynamic hasAttributes, attributes;
@dynamic childrenArray, childrenArray_Count;
@dynamic debugInfo;
@dynamic hasVideoHandler, videoHandler;
@dynamic hasLottieHandler, lottieHandler;
@dynamic gesturesArray, gesturesArray_Count;

typedef struct RIAIDNode__storage_ {
  uint32_t _has_storage_[1];
  RIAIDNode_ClassType classType;
  int32_t key;
  RIAIDLayout *layout;
  RIAIDHandler *handler;
  RIAIDAttributes *attributes;
  NSMutableArray *childrenArray;
  NSString *debugInfo;
  RIAIDVideoHandler *videoHandler;
  RIAIDLottieHandler *lottieHandler;
  NSMutableArray *gesturesArray;
} RIAIDNode__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "classType",
        .dataTypeSpecific.enumDescFunc = RIAIDNode_ClassType_EnumDescriptor,
        .number = RIAIDNode_FieldNumber_ClassType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RIAIDNode__storage_, classType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "key",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDNode_FieldNumber_Key,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RIAIDNode__storage_, key),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "layout",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDLayout),
        .number = RIAIDNode_FieldNumber_Layout,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RIAIDNode__storage_, layout),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "handler",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDHandler),
        .number = RIAIDNode_FieldNumber_Handler,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RIAIDNode__storage_, handler),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "attributes",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDAttributes),
        .number = RIAIDNode_FieldNumber_Attributes,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(RIAIDNode__storage_, attributes),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "childrenArray",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDNode),
        .number = RIAIDNode_FieldNumber_ChildrenArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RIAIDNode__storage_, childrenArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "debugInfo",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDNode_FieldNumber_DebugInfo,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(RIAIDNode__storage_, debugInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "videoHandler",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDVideoHandler),
        .number = RIAIDNode_FieldNumber_VideoHandler,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(RIAIDNode__storage_, videoHandler),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "lottieHandler",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDLottieHandler),
        .number = RIAIDNode_FieldNumber_LottieHandler,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(RIAIDNode__storage_, lottieHandler),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "gesturesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDGestureModel),
        .number = RIAIDNode_FieldNumber_GesturesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RIAIDNode__storage_, gesturesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RIAIDNode class]
                                     rootClass:[RIAIDRiaidRoot class]
                                          file:RIAIDRiaidRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RIAIDNode__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RIAIDNode_ClassType_RawValue(RIAIDNode *message) {
  GPBDescriptor *descriptor = [RIAIDNode descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RIAIDNode_FieldNumber_ClassType];
  return GPBGetMessageInt32Field(message, field);
}

void SetRIAIDNode_ClassType_RawValue(RIAIDNode *message, int32_t value) {
  GPBDescriptor *descriptor = [RIAIDNode descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RIAIDNode_FieldNumber_ClassType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum RIAIDNode_ClassType

GPBEnumDescriptor *RIAIDNode_ClassType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "ClassTypeUnknown\000ClassTypeItemImage\000Clas"
        "sTypeItemLottie\000ClassTypeItemSpace\000Class"
        "TypeItemText\000ClassTypeLayoutAbsolute\000Cla"
        "ssTypeLayoutButton\000ClassTypeLayoutHorizo"
        "ntal\000ClassTypeLayoutHScroll\000ClassTypeLay"
        "outSquare\000ClassTypeLayoutVertical\000ClassT"
        "ypeLayoutVScroll\000ClassTypeItemVideo\000Clas"
        "sTypeItemAnchor\000";
    static const int32_t values[] = {
        RIAIDNode_ClassType_ClassTypeUnknown,
        RIAIDNode_ClassType_ClassTypeItemImage,
        RIAIDNode_ClassType_ClassTypeItemLottie,
        RIAIDNode_ClassType_ClassTypeItemSpace,
        RIAIDNode_ClassType_ClassTypeItemText,
        RIAIDNode_ClassType_ClassTypeLayoutAbsolute,
        RIAIDNode_ClassType_ClassTypeLayoutButton,
        RIAIDNode_ClassType_ClassTypeLayoutHorizontal,
        RIAIDNode_ClassType_ClassTypeLayoutHScroll,
        RIAIDNode_ClassType_ClassTypeLayoutSquare,
        RIAIDNode_ClassType_ClassTypeLayoutVertical,
        RIAIDNode_ClassType_ClassTypeLayoutVScroll,
        RIAIDNode_ClassType_ClassTypeItemVideo,
        RIAIDNode_ClassType_ClassTypeItemAnchor,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(RIAIDNode_ClassType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:RIAIDNode_ClassType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL RIAIDNode_ClassType_IsValidValue(int32_t value__) {
  switch (value__) {
    case RIAIDNode_ClassType_ClassTypeUnknown:
    case RIAIDNode_ClassType_ClassTypeItemImage:
    case RIAIDNode_ClassType_ClassTypeItemLottie:
    case RIAIDNode_ClassType_ClassTypeItemSpace:
    case RIAIDNode_ClassType_ClassTypeItemText:
    case RIAIDNode_ClassType_ClassTypeLayoutAbsolute:
    case RIAIDNode_ClassType_ClassTypeLayoutButton:
    case RIAIDNode_ClassType_ClassTypeLayoutHorizontal:
    case RIAIDNode_ClassType_ClassTypeLayoutHScroll:
    case RIAIDNode_ClassType_ClassTypeLayoutSquare:
    case RIAIDNode_ClassType_ClassTypeLayoutVertical:
    case RIAIDNode_ClassType_ClassTypeLayoutVScroll:
    case RIAIDNode_ClassType_ClassTypeItemVideo:
    case RIAIDNode_ClassType_ClassTypeItemAnchor:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - RIAIDADConditionModel

@implementation RIAIDADConditionModel

@dynamic conditionName;
@dynamic conditionValue;

typedef struct RIAIDADConditionModel__storage_ {
  uint32_t _has_storage_[1];
  NSString *conditionName;
  NSString *conditionValue;
} RIAIDADConditionModel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "conditionName",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDADConditionModel_FieldNumber_ConditionName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RIAIDADConditionModel__storage_, conditionName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "conditionValue",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDADConditionModel_FieldNumber_ConditionValue,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RIAIDADConditionModel__storage_, conditionValue),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RIAIDADConditionModel class]
                                     rootClass:[RIAIDRiaidRoot class]
                                          file:RIAIDRiaidRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RIAIDADConditionModel__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RIAIDADLogicUnitModel

@implementation RIAIDADLogicUnitModel

@dynamic hasCondition, condition;
@dynamic compare;
@dynamic hasVariable, variable;

typedef struct RIAIDADLogicUnitModel__storage_ {
  uint32_t _has_storage_[1];
  RIAIDCompareOperator compare;
  RIAIDADConditionModel *condition;
  RIAIDBasicVariable *variable;
} RIAIDADLogicUnitModel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "condition",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDADConditionModel),
        .number = RIAIDADLogicUnitModel_FieldNumber_Condition,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RIAIDADLogicUnitModel__storage_, condition),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "compare",
        .dataTypeSpecific.enumDescFunc = RIAIDCompareOperator_EnumDescriptor,
        .number = RIAIDADLogicUnitModel_FieldNumber_Compare,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RIAIDADLogicUnitModel__storage_, compare),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "variable",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDBasicVariable),
        .number = RIAIDADLogicUnitModel_FieldNumber_Variable,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RIAIDADLogicUnitModel__storage_, variable),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RIAIDADLogicUnitModel class]
                                     rootClass:[RIAIDRiaidRoot class]
                                          file:RIAIDRiaidRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RIAIDADLogicUnitModel__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RIAIDADLogicUnitModel_Compare_RawValue(RIAIDADLogicUnitModel *message) {
  GPBDescriptor *descriptor = [RIAIDADLogicUnitModel descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RIAIDADLogicUnitModel_FieldNumber_Compare];
  return GPBGetMessageInt32Field(message, field);
}

void SetRIAIDADLogicUnitModel_Compare_RawValue(RIAIDADLogicUnitModel *message, int32_t value) {
  GPBDescriptor *descriptor = [RIAIDADLogicUnitModel descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RIAIDADLogicUnitModel_FieldNumber_Compare];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - RIAIDADConditionLogicModel

@implementation RIAIDADConditionLogicModel

@dynamic operator_p;
@dynamic unitsArray, unitsArray_Count;
@dynamic actionsArray, actionsArray_Count;

typedef struct RIAIDADConditionLogicModel__storage_ {
  uint32_t _has_storage_[1];
  RIAIDLogicOperator operator_p;
  NSMutableArray *unitsArray;
  NSMutableArray *actionsArray;
} RIAIDADConditionLogicModel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "operator_p",
        .dataTypeSpecific.enumDescFunc = RIAIDLogicOperator_EnumDescriptor,
        .number = RIAIDADConditionLogicModel_FieldNumber_Operator_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RIAIDADConditionLogicModel__storage_, operator_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "unitsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDADLogicUnitModel),
        .number = RIAIDADConditionLogicModel_FieldNumber_UnitsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RIAIDADConditionLogicModel__storage_, unitsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "actionsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDADActionModel),
        .number = RIAIDADConditionLogicModel_FieldNumber_ActionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RIAIDADConditionLogicModel__storage_, actionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RIAIDADConditionLogicModel class]
                                     rootClass:[RIAIDRiaidRoot class]
                                          file:RIAIDRiaidRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RIAIDADConditionLogicModel__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RIAIDADConditionLogicModel_Operator_p_RawValue(RIAIDADConditionLogicModel *message) {
  GPBDescriptor *descriptor = [RIAIDADConditionLogicModel descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RIAIDADConditionLogicModel_FieldNumber_Operator_p];
  return GPBGetMessageInt32Field(message, field);
}

void SetRIAIDADConditionLogicModel_Operator_p_RawValue(RIAIDADConditionLogicModel *message, int32_t value) {
  GPBDescriptor *descriptor = [RIAIDADConditionLogicModel descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RIAIDADConditionLogicModel_FieldNumber_Operator_p];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - RIAIDADConditionTriggerModel

@implementation RIAIDADConditionTriggerModel

@dynamic key;
@dynamic logicsArray, logicsArray_Count;
@dynamic debugInfo;

typedef struct RIAIDADConditionTriggerModel__storage_ {
  uint32_t _has_storage_[1];
  int32_t key;
  NSMutableArray *logicsArray;
  NSString *debugInfo;
} RIAIDADConditionTriggerModel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "key",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDADConditionTriggerModel_FieldNumber_Key,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RIAIDADConditionTriggerModel__storage_, key),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "logicsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDADConditionLogicModel),
        .number = RIAIDADConditionTriggerModel_FieldNumber_LogicsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RIAIDADConditionTriggerModel__storage_, logicsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "debugInfo",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDADConditionTriggerModel_FieldNumber_DebugInfo,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RIAIDADConditionTriggerModel__storage_, debugInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RIAIDADConditionTriggerModel class]
                                     rootClass:[RIAIDRiaidRoot class]
                                          file:RIAIDRiaidRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RIAIDADConditionTriggerModel__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RIAIDADTriggerModel

@implementation RIAIDADTriggerModel

@dynamic hasTimeout, timeout;
@dynamic hasHeartbeat, heartbeat;
@dynamic hasGeneral, general;
@dynamic hasCondition, condition;
@dynamic hasVideoDuration, videoDuration;
@dynamic hasDeviceMotion, deviceMotion;

typedef struct RIAIDADTriggerModel__storage_ {
  uint32_t _has_storage_[1];
  RIAIDADTimeoutTriggerModel *timeout;
  RIAIDADHeartBeatTriggerModel *heartbeat;
  RIAIDADGeneralTriggerModel *general;
  RIAIDADConditionTriggerModel *condition;
  RIAIDADVideoDurationTimeoutTriggerModel *videoDuration;
  RIAIDADDeviceMotionTriggerModel *deviceMotion;
} RIAIDADTriggerModel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "timeout",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDADTimeoutTriggerModel),
        .number = RIAIDADTriggerModel_FieldNumber_Timeout,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RIAIDADTriggerModel__storage_, timeout),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "heartbeat",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDADHeartBeatTriggerModel),
        .number = RIAIDADTriggerModel_FieldNumber_Heartbeat,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RIAIDADTriggerModel__storage_, heartbeat),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "general",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDADGeneralTriggerModel),
        .number = RIAIDADTriggerModel_FieldNumber_General,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RIAIDADTriggerModel__storage_, general),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "condition",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDADConditionTriggerModel),
        .number = RIAIDADTriggerModel_FieldNumber_Condition,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RIAIDADTriggerModel__storage_, condition),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "videoDuration",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDADVideoDurationTimeoutTriggerModel),
        .number = RIAIDADTriggerModel_FieldNumber_VideoDuration,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(RIAIDADTriggerModel__storage_, videoDuration),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "deviceMotion",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDADDeviceMotionTriggerModel),
        .number = RIAIDADTriggerModel_FieldNumber_DeviceMotion,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(RIAIDADTriggerModel__storage_, deviceMotion),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RIAIDADTriggerModel class]
                                     rootClass:[RIAIDRiaidRoot class]
                                          file:RIAIDRiaidRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RIAIDADTriggerModel__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\005\r\000\006\014\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RIAIDADTimeoutTriggerModel

@implementation RIAIDADTimeoutTriggerModel

@dynamic key;
@dynamic interval;
@dynamic actionsArray, actionsArray_Count;
@dynamic debugInfo;

typedef struct RIAIDADTimeoutTriggerModel__storage_ {
  uint32_t _has_storage_[1];
  int32_t key;
  NSMutableArray *actionsArray;
  NSString *debugInfo;
  int64_t interval;
} RIAIDADTimeoutTriggerModel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "key",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDADTimeoutTriggerModel_FieldNumber_Key,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RIAIDADTimeoutTriggerModel__storage_, key),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "interval",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDADTimeoutTriggerModel_FieldNumber_Interval,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RIAIDADTimeoutTriggerModel__storage_, interval),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "actionsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDADActionModel),
        .number = RIAIDADTimeoutTriggerModel_FieldNumber_ActionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RIAIDADTimeoutTriggerModel__storage_, actionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "debugInfo",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDADTimeoutTriggerModel_FieldNumber_DebugInfo,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RIAIDADTimeoutTriggerModel__storage_, debugInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RIAIDADTimeoutTriggerModel class]
                                     rootClass:[RIAIDRiaidRoot class]
                                          file:RIAIDRiaidRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RIAIDADTimeoutTriggerModel__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RIAIDADHeartBeatTriggerModel

@implementation RIAIDADHeartBeatTriggerModel

@dynamic key;
@dynamic interval;
@dynamic count;
@dynamic actionsArray, actionsArray_Count;
@dynamic debugInfo;

typedef struct RIAIDADHeartBeatTriggerModel__storage_ {
  uint32_t _has_storage_[1];
  int32_t key;
  int32_t count;
  NSMutableArray *actionsArray;
  NSString *debugInfo;
  int64_t interval;
} RIAIDADHeartBeatTriggerModel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "key",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDADHeartBeatTriggerModel_FieldNumber_Key,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RIAIDADHeartBeatTriggerModel__storage_, key),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "interval",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDADHeartBeatTriggerModel_FieldNumber_Interval,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RIAIDADHeartBeatTriggerModel__storage_, interval),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "count",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDADHeartBeatTriggerModel_FieldNumber_Count,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RIAIDADHeartBeatTriggerModel__storage_, count),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "actionsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDADActionModel),
        .number = RIAIDADHeartBeatTriggerModel_FieldNumber_ActionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RIAIDADHeartBeatTriggerModel__storage_, actionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "debugInfo",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDADHeartBeatTriggerModel_FieldNumber_DebugInfo,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RIAIDADHeartBeatTriggerModel__storage_, debugInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RIAIDADHeartBeatTriggerModel class]
                                     rootClass:[RIAIDRiaidRoot class]
                                          file:RIAIDRiaidRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RIAIDADHeartBeatTriggerModel__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RIAIDADGeneralTriggerModel

@implementation RIAIDADGeneralTriggerModel

@dynamic key;
@dynamic actionsArray, actionsArray_Count;
@dynamic debugInfo;

typedef struct RIAIDADGeneralTriggerModel__storage_ {
  uint32_t _has_storage_[1];
  int32_t key;
  NSMutableArray *actionsArray;
  NSString *debugInfo;
} RIAIDADGeneralTriggerModel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "key",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDADGeneralTriggerModel_FieldNumber_Key,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RIAIDADGeneralTriggerModel__storage_, key),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "actionsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDADActionModel),
        .number = RIAIDADGeneralTriggerModel_FieldNumber_ActionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RIAIDADGeneralTriggerModel__storage_, actionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "debugInfo",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDADGeneralTriggerModel_FieldNumber_DebugInfo,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RIAIDADGeneralTriggerModel__storage_, debugInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RIAIDADGeneralTriggerModel class]
                                     rootClass:[RIAIDRiaidRoot class]
                                          file:RIAIDRiaidRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RIAIDADGeneralTriggerModel__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RIAIDADVideoDurationTimeoutTriggerModel

@implementation RIAIDADVideoDurationTimeoutTriggerModel

@dynamic key;
@dynamic viewKey;
@dynamic interval;
@dynamic actionsArray, actionsArray_Count;
@dynamic debugInfo;

typedef struct RIAIDADVideoDurationTimeoutTriggerModel__storage_ {
  uint32_t _has_storage_[1];
  int32_t key;
  int32_t viewKey;
  NSMutableArray *actionsArray;
  NSString *debugInfo;
  int64_t interval;
} RIAIDADVideoDurationTimeoutTriggerModel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "key",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDADVideoDurationTimeoutTriggerModel_FieldNumber_Key,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RIAIDADVideoDurationTimeoutTriggerModel__storage_, key),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "viewKey",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDADVideoDurationTimeoutTriggerModel_FieldNumber_ViewKey,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RIAIDADVideoDurationTimeoutTriggerModel__storage_, viewKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "interval",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDADVideoDurationTimeoutTriggerModel_FieldNumber_Interval,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RIAIDADVideoDurationTimeoutTriggerModel__storage_, interval),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "actionsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDADActionModel),
        .number = RIAIDADVideoDurationTimeoutTriggerModel_FieldNumber_ActionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RIAIDADVideoDurationTimeoutTriggerModel__storage_, actionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "debugInfo",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDADVideoDurationTimeoutTriggerModel_FieldNumber_DebugInfo,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RIAIDADVideoDurationTimeoutTriggerModel__storage_, debugInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RIAIDADVideoDurationTimeoutTriggerModel class]
                                     rootClass:[RIAIDRiaidRoot class]
                                          file:RIAIDRiaidRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RIAIDADVideoDurationTimeoutTriggerModel__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RIAIDDeviceAxisUnitModel

@implementation RIAIDDeviceAxisUnitModel

@dynamic type;
@dynamic threshold;
@dynamic compare;

typedef struct RIAIDDeviceAxisUnitModel__storage_ {
  uint32_t _has_storage_[1];
  RIAIDDeviceAxisType type;
  float threshold;
  RIAIDCompareOperator compare;
} RIAIDDeviceAxisUnitModel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = RIAIDDeviceAxisType_EnumDescriptor,
        .number = RIAIDDeviceAxisUnitModel_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RIAIDDeviceAxisUnitModel__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "threshold",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDDeviceAxisUnitModel_FieldNumber_Threshold,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RIAIDDeviceAxisUnitModel__storage_, threshold),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "compare",
        .dataTypeSpecific.enumDescFunc = RIAIDCompareOperator_EnumDescriptor,
        .number = RIAIDDeviceAxisUnitModel_FieldNumber_Compare,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RIAIDDeviceAxisUnitModel__storage_, compare),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RIAIDDeviceAxisUnitModel class]
                                     rootClass:[RIAIDRiaidRoot class]
                                          file:RIAIDRiaidRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RIAIDDeviceAxisUnitModel__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RIAIDDeviceAxisUnitModel_Type_RawValue(RIAIDDeviceAxisUnitModel *message) {
  GPBDescriptor *descriptor = [RIAIDDeviceAxisUnitModel descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RIAIDDeviceAxisUnitModel_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetRIAIDDeviceAxisUnitModel_Type_RawValue(RIAIDDeviceAxisUnitModel *message, int32_t value) {
  GPBDescriptor *descriptor = [RIAIDDeviceAxisUnitModel descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RIAIDDeviceAxisUnitModel_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t RIAIDDeviceAxisUnitModel_Compare_RawValue(RIAIDDeviceAxisUnitModel *message) {
  GPBDescriptor *descriptor = [RIAIDDeviceAxisUnitModel descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RIAIDDeviceAxisUnitModel_FieldNumber_Compare];
  return GPBGetMessageInt32Field(message, field);
}

void SetRIAIDDeviceAxisUnitModel_Compare_RawValue(RIAIDDeviceAxisUnitModel *message, int32_t value) {
  GPBDescriptor *descriptor = [RIAIDDeviceAxisUnitModel descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RIAIDDeviceAxisUnitModel_FieldNumber_Compare];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - RIAIDDeviceAxisConditionModel

@implementation RIAIDDeviceAxisConditionModel

@dynamic unitsArray, unitsArray_Count;
@dynamic operator_p;

typedef struct RIAIDDeviceAxisConditionModel__storage_ {
  uint32_t _has_storage_[1];
  RIAIDLogicOperator operator_p;
  NSMutableArray *unitsArray;
} RIAIDDeviceAxisConditionModel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "unitsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDDeviceAxisUnitModel),
        .number = RIAIDDeviceAxisConditionModel_FieldNumber_UnitsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RIAIDDeviceAxisConditionModel__storage_, unitsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "operator_p",
        .dataTypeSpecific.enumDescFunc = RIAIDLogicOperator_EnumDescriptor,
        .number = RIAIDDeviceAxisConditionModel_FieldNumber_Operator_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RIAIDDeviceAxisConditionModel__storage_, operator_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RIAIDDeviceAxisConditionModel class]
                                     rootClass:[RIAIDRiaidRoot class]
                                          file:RIAIDRiaidRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RIAIDDeviceAxisConditionModel__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RIAIDDeviceAxisConditionModel_Operator_p_RawValue(RIAIDDeviceAxisConditionModel *message) {
  GPBDescriptor *descriptor = [RIAIDDeviceAxisConditionModel descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RIAIDDeviceAxisConditionModel_FieldNumber_Operator_p];
  return GPBGetMessageInt32Field(message, field);
}

void SetRIAIDDeviceAxisConditionModel_Operator_p_RawValue(RIAIDDeviceAxisConditionModel *message, int32_t value) {
  GPBDescriptor *descriptor = [RIAIDDeviceAxisConditionModel descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RIAIDDeviceAxisConditionModel_FieldNumber_Operator_p];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - RIAIDADDeviceMotionTriggerModel

@implementation RIAIDADDeviceMotionTriggerModel

@dynamic key;
@dynamic motionType;
@dynamic hasCondition, condition;
@dynamic actionsArray, actionsArray_Count;

typedef struct RIAIDADDeviceMotionTriggerModel__storage_ {
  uint32_t _has_storage_[1];
  int32_t key;
  RIAIDADDeviceMotionTriggerModel_DeviceMotionType motionType;
  RIAIDDeviceAxisConditionModel *condition;
  NSMutableArray *actionsArray;
} RIAIDADDeviceMotionTriggerModel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "key",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDADDeviceMotionTriggerModel_FieldNumber_Key,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RIAIDADDeviceMotionTriggerModel__storage_, key),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "motionType",
        .dataTypeSpecific.enumDescFunc = RIAIDADDeviceMotionTriggerModel_DeviceMotionType_EnumDescriptor,
        .number = RIAIDADDeviceMotionTriggerModel_FieldNumber_MotionType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RIAIDADDeviceMotionTriggerModel__storage_, motionType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "condition",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDDeviceAxisConditionModel),
        .number = RIAIDADDeviceMotionTriggerModel_FieldNumber_Condition,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RIAIDADDeviceMotionTriggerModel__storage_, condition),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "actionsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDADActionModel),
        .number = RIAIDADDeviceMotionTriggerModel_FieldNumber_ActionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RIAIDADDeviceMotionTriggerModel__storage_, actionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RIAIDADDeviceMotionTriggerModel class]
                                     rootClass:[RIAIDRiaidRoot class]
                                          file:RIAIDRiaidRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RIAIDADDeviceMotionTriggerModel__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RIAIDADDeviceMotionTriggerModel_MotionType_RawValue(RIAIDADDeviceMotionTriggerModel *message) {
  GPBDescriptor *descriptor = [RIAIDADDeviceMotionTriggerModel descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RIAIDADDeviceMotionTriggerModel_FieldNumber_MotionType];
  return GPBGetMessageInt32Field(message, field);
}

void SetRIAIDADDeviceMotionTriggerModel_MotionType_RawValue(RIAIDADDeviceMotionTriggerModel *message, int32_t value) {
  GPBDescriptor *descriptor = [RIAIDADDeviceMotionTriggerModel descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RIAIDADDeviceMotionTriggerModel_FieldNumber_MotionType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum RIAIDADDeviceMotionTriggerModel_DeviceMotionType

GPBEnumDescriptor *RIAIDADDeviceMotionTriggerModel_DeviceMotionType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "DeviceMotionTypeUnknown\000DeviceMotionType"
        "Useracceleration\000DeviceMotionTypeRotatio"
        "nrate\000";
    static const int32_t values[] = {
        RIAIDADDeviceMotionTriggerModel_DeviceMotionType_DeviceMotionTypeUnknown,
        RIAIDADDeviceMotionTriggerModel_DeviceMotionType_DeviceMotionTypeUseracceleration,
        RIAIDADDeviceMotionTriggerModel_DeviceMotionType_DeviceMotionTypeRotationrate,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(RIAIDADDeviceMotionTriggerModel_DeviceMotionType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:RIAIDADDeviceMotionTriggerModel_DeviceMotionType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL RIAIDADDeviceMotionTriggerModel_DeviceMotionType_IsValidValue(int32_t value__) {
  switch (value__) {
    case RIAIDADDeviceMotionTriggerModel_DeviceMotionType_DeviceMotionTypeUnknown:
    case RIAIDADDeviceMotionTriggerModel_DeviceMotionType_DeviceMotionTypeUseracceleration:
    case RIAIDADDeviceMotionTriggerModel_DeviceMotionType_DeviceMotionTypeRotationrate:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - RIAIDADTransitionModel

@implementation RIAIDADTransitionModel

@dynamic hasVisibility, visibility;
@dynamic hasTemplate_p, template_p;
@dynamic hasTranslation, translation;
@dynamic hasInSceneAnimation, inSceneAnimation;
@dynamic hasSceneShare, sceneShare;
@dynamic hasLottie, lottie;
@dynamic hasRenderContent, renderContent;
@dynamic hasBezier, bezier;

typedef struct RIAIDADTransitionModel__storage_ {
  uint32_t _has_storage_[1];
  RIAIDADVisibilityTransitionModel *visibility;
  RIAIDADTemplateTransitionModel *template_p;
  RIAIDADTranslationTransitionModel *translation;
  RIAIDADInSceneAnimationTransitionModel *inSceneAnimation;
  RIAIDADSceneShareTransitionModel *sceneShare;
  RIAIDADLottieTransitionModel *lottie;
  RIAIDADRenderContentTransitionModel *renderContent;
  RIAIDADBezierTransitionModel *bezier;
} RIAIDADTransitionModel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "visibility",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDADVisibilityTransitionModel),
        .number = RIAIDADTransitionModel_FieldNumber_Visibility,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RIAIDADTransitionModel__storage_, visibility),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "template_p",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDADTemplateTransitionModel),
        .number = RIAIDADTransitionModel_FieldNumber_Template_p,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RIAIDADTransitionModel__storage_, template_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "translation",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDADTranslationTransitionModel),
        .number = RIAIDADTransitionModel_FieldNumber_Translation,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RIAIDADTransitionModel__storage_, translation),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "inSceneAnimation",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDADInSceneAnimationTransitionModel),
        .number = RIAIDADTransitionModel_FieldNumber_InSceneAnimation,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RIAIDADTransitionModel__storage_, inSceneAnimation),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "sceneShare",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDADSceneShareTransitionModel),
        .number = RIAIDADTransitionModel_FieldNumber_SceneShare,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(RIAIDADTransitionModel__storage_, sceneShare),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "lottie",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDADLottieTransitionModel),
        .number = RIAIDADTransitionModel_FieldNumber_Lottie,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(RIAIDADTransitionModel__storage_, lottie),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "renderContent",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDADRenderContentTransitionModel),
        .number = RIAIDADTransitionModel_FieldNumber_RenderContent,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(RIAIDADTransitionModel__storage_, renderContent),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "bezier",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDADBezierTransitionModel),
        .number = RIAIDADTransitionModel_FieldNumber_Bezier,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(RIAIDADTransitionModel__storage_, bezier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RIAIDADTransitionModel class]
                                     rootClass:[RIAIDRiaidRoot class]
                                          file:RIAIDRiaidRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RIAIDADTransitionModel__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RIAIDADVisibilityTransitionModel

@implementation RIAIDADVisibilityTransitionModel

@dynamic sceneKey;
@dynamic duration;
@dynamic startAlpha;
@dynamic endAlpha;
@dynamic hidden;

typedef struct RIAIDADVisibilityTransitionModel__storage_ {
  uint32_t _has_storage_[1];
  int32_t sceneKey;
  float startAlpha;
  float endAlpha;
  int64_t duration;
} RIAIDADVisibilityTransitionModel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sceneKey",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDADVisibilityTransitionModel_FieldNumber_SceneKey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RIAIDADVisibilityTransitionModel__storage_, sceneKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "duration",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDADVisibilityTransitionModel_FieldNumber_Duration,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RIAIDADVisibilityTransitionModel__storage_, duration),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "startAlpha",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDADVisibilityTransitionModel_FieldNumber_StartAlpha,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RIAIDADVisibilityTransitionModel__storage_, startAlpha),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "endAlpha",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDADVisibilityTransitionModel_FieldNumber_EndAlpha,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RIAIDADVisibilityTransitionModel__storage_, endAlpha),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "hidden",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDADVisibilityTransitionModel_FieldNumber_Hidden,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RIAIDADVisibilityTransitionModel class]
                                     rootClass:[RIAIDRiaidRoot class]
                                          file:RIAIDRiaidRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RIAIDADVisibilityTransitionModel__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RIAIDADTemplateTransitionModel

@implementation RIAIDADTemplateTransitionModel

@dynamic sceneKey;
@dynamic duration;
@dynamic template_p;

typedef struct RIAIDADTemplateTransitionModel__storage_ {
  uint32_t _has_storage_[1];
  int32_t sceneKey;
  RIAIDADTemplateTransitionModel_TemplateType template_p;
  int64_t duration;
} RIAIDADTemplateTransitionModel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sceneKey",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDADTemplateTransitionModel_FieldNumber_SceneKey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RIAIDADTemplateTransitionModel__storage_, sceneKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "duration",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDADTemplateTransitionModel_FieldNumber_Duration,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RIAIDADTemplateTransitionModel__storage_, duration),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "template_p",
        .dataTypeSpecific.enumDescFunc = RIAIDADTemplateTransitionModel_TemplateType_EnumDescriptor,
        .number = RIAIDADTemplateTransitionModel_FieldNumber_Template_p,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RIAIDADTemplateTransitionModel__storage_, template_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RIAIDADTemplateTransitionModel class]
                                     rootClass:[RIAIDRiaidRoot class]
                                          file:RIAIDRiaidRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RIAIDADTemplateTransitionModel__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RIAIDADTemplateTransitionModel_Template_p_RawValue(RIAIDADTemplateTransitionModel *message) {
  GPBDescriptor *descriptor = [RIAIDADTemplateTransitionModel descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RIAIDADTemplateTransitionModel_FieldNumber_Template_p];
  return GPBGetMessageInt32Field(message, field);
}

void SetRIAIDADTemplateTransitionModel_Template_p_RawValue(RIAIDADTemplateTransitionModel *message, int32_t value) {
  GPBDescriptor *descriptor = [RIAIDADTemplateTransitionModel descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RIAIDADTemplateTransitionModel_FieldNumber_Template_p];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum RIAIDADTemplateTransitionModel_TemplateType

GPBEnumDescriptor *RIAIDADTemplateTransitionModel_TemplateType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "TemplateTypeNone\000EnterFromStart\000ExitFrom"
        "Start\000";
    static const int32_t values[] = {
        RIAIDADTemplateTransitionModel_TemplateType_TemplateTypeNone,
        RIAIDADTemplateTransitionModel_TemplateType_EnterFromStart,
        RIAIDADTemplateTransitionModel_TemplateType_ExitFromStart,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(RIAIDADTemplateTransitionModel_TemplateType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:RIAIDADTemplateTransitionModel_TemplateType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL RIAIDADTemplateTransitionModel_TemplateType_IsValidValue(int32_t value__) {
  switch (value__) {
    case RIAIDADTemplateTransitionModel_TemplateType_TemplateTypeNone:
    case RIAIDADTemplateTransitionModel_TemplateType_EnterFromStart:
    case RIAIDADTemplateTransitionModel_TemplateType_ExitFromStart:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - RIAIDADTranslationTransitionModel

@implementation RIAIDADTranslationTransitionModel

@dynamic sceneKey;
@dynamic duration;
@dynamic sceneRelationsArray, sceneRelationsArray_Count;

typedef struct RIAIDADTranslationTransitionModel__storage_ {
  uint32_t _has_storage_[1];
  int32_t sceneKey;
  NSMutableArray *sceneRelationsArray;
  int64_t duration;
} RIAIDADTranslationTransitionModel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sceneKey",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDADTranslationTransitionModel_FieldNumber_SceneKey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RIAIDADTranslationTransitionModel__storage_, sceneKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "duration",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDADTranslationTransitionModel_FieldNumber_Duration,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RIAIDADTranslationTransitionModel__storage_, duration),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "sceneRelationsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDADSceneRelationModel),
        .number = RIAIDADTranslationTransitionModel_FieldNumber_SceneRelationsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RIAIDADTranslationTransitionModel__storage_, sceneRelationsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RIAIDADTranslationTransitionModel class]
                                     rootClass:[RIAIDRiaidRoot class]
                                          file:RIAIDRiaidRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RIAIDADTranslationTransitionModel__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RIAIDADInSceneAnimationTransitionModel

@implementation RIAIDADInSceneAnimationTransitionModel

@dynamic viewKey;
@dynamic sceneKey;
@dynamic hasAnimation, animation;

typedef struct RIAIDADInSceneAnimationTransitionModel__storage_ {
  uint32_t _has_storage_[1];
  int32_t viewKey;
  int32_t sceneKey;
  RIAIDADAnimationModel *animation;
} RIAIDADInSceneAnimationTransitionModel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "viewKey",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDADInSceneAnimationTransitionModel_FieldNumber_ViewKey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RIAIDADInSceneAnimationTransitionModel__storage_, viewKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "sceneKey",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDADInSceneAnimationTransitionModel_FieldNumber_SceneKey,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RIAIDADInSceneAnimationTransitionModel__storage_, sceneKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "animation",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDADAnimationModel),
        .number = RIAIDADInSceneAnimationTransitionModel_FieldNumber_Animation,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RIAIDADInSceneAnimationTransitionModel__storage_, animation),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RIAIDADInSceneAnimationTransitionModel class]
                                     rootClass:[RIAIDRiaidRoot class]
                                          file:RIAIDRiaidRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RIAIDADInSceneAnimationTransitionModel__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RIAIDADSceneShareTransitionModel

@implementation RIAIDADSceneShareTransitionModel

@dynamic startSceneKey;
@dynamic endSceneKey;
@dynamic duration;

typedef struct RIAIDADSceneShareTransitionModel__storage_ {
  uint32_t _has_storage_[1];
  int32_t startSceneKey;
  int32_t endSceneKey;
  int64_t duration;
} RIAIDADSceneShareTransitionModel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "startSceneKey",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDADSceneShareTransitionModel_FieldNumber_StartSceneKey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RIAIDADSceneShareTransitionModel__storage_, startSceneKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "endSceneKey",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDADSceneShareTransitionModel_FieldNumber_EndSceneKey,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RIAIDADSceneShareTransitionModel__storage_, endSceneKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "duration",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDADSceneShareTransitionModel_FieldNumber_Duration,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RIAIDADSceneShareTransitionModel__storage_, duration),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RIAIDADSceneShareTransitionModel class]
                                     rootClass:[RIAIDRiaidRoot class]
                                          file:RIAIDRiaidRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RIAIDADSceneShareTransitionModel__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RIAIDADLottieTransitionModel

@implementation RIAIDADLottieTransitionModel

@dynamic sceneKey;
@dynamic lottieType;
@dynamic viewKeysArray, viewKeysArray_Count;
@dynamic maxProgress;
@dynamic interval;

typedef struct RIAIDADLottieTransitionModel__storage_ {
  uint32_t _has_storage_[1];
  int32_t sceneKey;
  NSString *lottieType;
  GPBInt32Array *viewKeysArray;
  int64_t maxProgress;
  int64_t interval;
} RIAIDADLottieTransitionModel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sceneKey",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDADLottieTransitionModel_FieldNumber_SceneKey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RIAIDADLottieTransitionModel__storage_, sceneKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "lottieType",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDADLottieTransitionModel_FieldNumber_LottieType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RIAIDADLottieTransitionModel__storage_, lottieType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "viewKeysArray",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDADLottieTransitionModel_FieldNumber_ViewKeysArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RIAIDADLottieTransitionModel__storage_, viewKeysArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "maxProgress",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDADLottieTransitionModel_FieldNumber_MaxProgress,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RIAIDADLottieTransitionModel__storage_, maxProgress),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "interval",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDADLottieTransitionModel_FieldNumber_Interval,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RIAIDADLottieTransitionModel__storage_, interval),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RIAIDADLottieTransitionModel class]
                                     rootClass:[RIAIDRiaidRoot class]
                                          file:RIAIDRiaidRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RIAIDADLottieTransitionModel__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RIAIDADRenderContentTransitionModel

@implementation RIAIDADRenderContentTransitionModel

@dynamic sceneKey;
@dynamic viewKey;
@dynamic hasRenderAttributes, renderAttributes;

typedef struct RIAIDADRenderContentTransitionModel__storage_ {
  uint32_t _has_storage_[1];
  int32_t sceneKey;
  int32_t viewKey;
  RIAIDAttributes *renderAttributes;
} RIAIDADRenderContentTransitionModel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sceneKey",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDADRenderContentTransitionModel_FieldNumber_SceneKey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RIAIDADRenderContentTransitionModel__storage_, sceneKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "viewKey",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDADRenderContentTransitionModel_FieldNumber_ViewKey,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RIAIDADRenderContentTransitionModel__storage_, viewKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "renderAttributes",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDAttributes),
        .number = RIAIDADRenderContentTransitionModel_FieldNumber_RenderAttributes,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RIAIDADRenderContentTransitionModel__storage_, renderAttributes),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RIAIDADRenderContentTransitionModel class]
                                     rootClass:[RIAIDRiaidRoot class]
                                          file:RIAIDRiaidRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RIAIDADRenderContentTransitionModel__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RIAIDADBezierTransitionModel

@implementation RIAIDADBezierTransitionModel

@dynamic startSceneKey;
@dynamic targetSceneKey;
@dynamic hasEndPointOffsetTargetScene, endPointOffsetTargetScene;
@dynamic hasControlFirstPointOffsetStartScene, controlFirstPointOffsetStartScene;
@dynamic hasControlSecondPointOffsetTargetScene, controlSecondPointOffsetTargetScene;
@dynamic duration;

typedef struct RIAIDADBezierTransitionModel__storage_ {
  uint32_t _has_storage_[1];
  int32_t startSceneKey;
  int32_t targetSceneKey;
  RIAIDPoint *endPointOffsetTargetScene;
  RIAIDPoint *controlFirstPointOffsetStartScene;
  RIAIDPoint *controlSecondPointOffsetTargetScene;
  int64_t duration;
} RIAIDADBezierTransitionModel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "startSceneKey",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDADBezierTransitionModel_FieldNumber_StartSceneKey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RIAIDADBezierTransitionModel__storage_, startSceneKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "targetSceneKey",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDADBezierTransitionModel_FieldNumber_TargetSceneKey,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RIAIDADBezierTransitionModel__storage_, targetSceneKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "endPointOffsetTargetScene",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDPoint),
        .number = RIAIDADBezierTransitionModel_FieldNumber_EndPointOffsetTargetScene,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RIAIDADBezierTransitionModel__storage_, endPointOffsetTargetScene),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "controlFirstPointOffsetStartScene",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDPoint),
        .number = RIAIDADBezierTransitionModel_FieldNumber_ControlFirstPointOffsetStartScene,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RIAIDADBezierTransitionModel__storage_, controlFirstPointOffsetStartScene),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "controlSecondPointOffsetTargetScene",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDPoint),
        .number = RIAIDADBezierTransitionModel_FieldNumber_ControlSecondPointOffsetTargetScene,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(RIAIDADBezierTransitionModel__storage_, controlSecondPointOffsetTargetScene),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "duration",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDADBezierTransitionModel_FieldNumber_Duration,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(RIAIDADBezierTransitionModel__storage_, duration),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RIAIDADBezierTransitionModel class]
                                     rootClass:[RIAIDRiaidRoot class]
                                          file:RIAIDRiaidRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RIAIDADBezierTransitionModel__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RIAIDADAnimationModel

@implementation RIAIDADAnimationModel

@dynamic propertyType;
@dynamic duration;
@dynamic repeatCount;
@dynamic valuesArray, valuesArray_Count;
@dynamic hasPivotX, pivotX;
@dynamic hasPivotY, pivotY;

typedef struct RIAIDADAnimationModel__storage_ {
  uint32_t _has_storage_[1];
  RIAIDADAnimationModel_ViewPropertyType propertyType;
  int32_t repeatCount;
  GPBFloatArray *valuesArray;
  RIAIDFloatValue *pivotX;
  RIAIDFloatValue *pivotY;
  int64_t duration;
} RIAIDADAnimationModel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "propertyType",
        .dataTypeSpecific.enumDescFunc = RIAIDADAnimationModel_ViewPropertyType_EnumDescriptor,
        .number = RIAIDADAnimationModel_FieldNumber_PropertyType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RIAIDADAnimationModel__storage_, propertyType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "duration",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDADAnimationModel_FieldNumber_Duration,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RIAIDADAnimationModel__storage_, duration),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "repeatCount",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDADAnimationModel_FieldNumber_RepeatCount,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RIAIDADAnimationModel__storage_, repeatCount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "valuesArray",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDADAnimationModel_FieldNumber_ValuesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RIAIDADAnimationModel__storage_, valuesArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "pivotX",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDFloatValue),
        .number = RIAIDADAnimationModel_FieldNumber_PivotX,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RIAIDADAnimationModel__storage_, pivotX),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "pivotY",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDFloatValue),
        .number = RIAIDADAnimationModel_FieldNumber_PivotY,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(RIAIDADAnimationModel__storage_, pivotY),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RIAIDADAnimationModel class]
                                     rootClass:[RIAIDRiaidRoot class]
                                          file:RIAIDRiaidRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RIAIDADAnimationModel__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\005F\000\006F\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RIAIDADAnimationModel_PropertyType_RawValue(RIAIDADAnimationModel *message) {
  GPBDescriptor *descriptor = [RIAIDADAnimationModel descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RIAIDADAnimationModel_FieldNumber_PropertyType];
  return GPBGetMessageInt32Field(message, field);
}

void SetRIAIDADAnimationModel_PropertyType_RawValue(RIAIDADAnimationModel *message, int32_t value) {
  GPBDescriptor *descriptor = [RIAIDADAnimationModel descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RIAIDADAnimationModel_FieldNumber_PropertyType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum RIAIDADAnimationModel_ViewPropertyType

GPBEnumDescriptor *RIAIDADAnimationModel_ViewPropertyType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "ViewPropertyNone\000Alpha\000Scale\000Rotation\000Wi"
        "dth\000Height\000Hidden\000";
    static const int32_t values[] = {
        RIAIDADAnimationModel_ViewPropertyType_ViewPropertyNone,
        RIAIDADAnimationModel_ViewPropertyType_Alpha,
        RIAIDADAnimationModel_ViewPropertyType_Scale,
        RIAIDADAnimationModel_ViewPropertyType_Rotation,
        RIAIDADAnimationModel_ViewPropertyType_Width,
        RIAIDADAnimationModel_ViewPropertyType_Height,
        RIAIDADAnimationModel_ViewPropertyType_Hidden,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(RIAIDADAnimationModel_ViewPropertyType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:RIAIDADAnimationModel_ViewPropertyType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL RIAIDADAnimationModel_ViewPropertyType_IsValidValue(int32_t value__) {
  switch (value__) {
    case RIAIDADAnimationModel_ViewPropertyType_ViewPropertyNone:
    case RIAIDADAnimationModel_ViewPropertyType_Alpha:
    case RIAIDADAnimationModel_ViewPropertyType_Scale:
    case RIAIDADAnimationModel_ViewPropertyType_Rotation:
    case RIAIDADAnimationModel_ViewPropertyType_Width:
    case RIAIDADAnimationModel_ViewPropertyType_Height:
    case RIAIDADAnimationModel_ViewPropertyType_Hidden:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - RIAIDADActionModel

@implementation RIAIDADActionModel

@dynamic hasTransition, transition;
@dynamic hasTrack, track;
@dynamic hasVideo, video;
@dynamic hasURL, URL;
@dynamic hasConditionChange, conditionChange;
@dynamic hasCancelTimer, cancelTimer;
@dynamic hasCustom, custom;
@dynamic hasTrigger, trigger;
@dynamic hasConversion, conversion;
@dynamic hasStep, step;
@dynamic hasVariableChange, variableChange;
@dynamic hasCancelDeviceMotion, cancelDeviceMotion;
@dynamic hasVibrator, vibrator;
@dynamic hasBeep, beep;
@dynamic hasLottie, lottie;
@dynamic hasClickable, clickable;
@dynamic hasToast, toast;
@dynamic hasFunction, function;
@dynamic hasDynamic, dynamic;

typedef struct RIAIDADActionModel__storage_ {
  uint32_t _has_storage_[1];
  RIAIDADTransitionActionModel *transition;
  RIAIDADTrackActionModel *track;
  RIAIDADVideoActionModel *video;
  RIAIDADUrlActionModel *URL;
  RIAIDADConditionChangeActionModel *conditionChange;
  RIAIDADCancelTimerActionModel *cancelTimer;
  RIAIDADCustomActionModel *custom;
  RIAIDADTriggerActionModel *trigger;
  RIAIDADConversionActionModel *conversion;
  RIAIDADStepActionModel *step;
  RIAIDADVariableChangeActionModel *variableChange;
  RIAIDADCancelDeviceMotionActionModel *cancelDeviceMotion;
  RIAIDADVibratorActionModel *vibrator;
  RIAIDADBeepActionModel *beep;
  RIAIDADLottieActionModel *lottie;
  RIAIDADClickableActionModel *clickable;
  RIAIDADToastActionModel *toast;
  RIAIDADExecuteFunctionActionModel *function;
  RIAIDADDynamicTrackActionModel *dynamic;
} RIAIDADActionModel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "transition",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDADTransitionActionModel),
        .number = RIAIDADActionModel_FieldNumber_Transition,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RIAIDADActionModel__storage_, transition),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "track",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDADTrackActionModel),
        .number = RIAIDADActionModel_FieldNumber_Track,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RIAIDADActionModel__storage_, track),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "video",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDADVideoActionModel),
        .number = RIAIDADActionModel_FieldNumber_Video,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RIAIDADActionModel__storage_, video),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "URL",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDADUrlActionModel),
        .number = RIAIDADActionModel_FieldNumber_URL,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RIAIDADActionModel__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "conditionChange",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDADConditionChangeActionModel),
        .number = RIAIDADActionModel_FieldNumber_ConditionChange,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(RIAIDADActionModel__storage_, conditionChange),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "cancelTimer",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDADCancelTimerActionModel),
        .number = RIAIDADActionModel_FieldNumber_CancelTimer,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(RIAIDADActionModel__storage_, cancelTimer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "custom",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDADCustomActionModel),
        .number = RIAIDADActionModel_FieldNumber_Custom,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(RIAIDADActionModel__storage_, custom),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "trigger",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDADTriggerActionModel),
        .number = RIAIDADActionModel_FieldNumber_Trigger,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(RIAIDADActionModel__storage_, trigger),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "conversion",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDADConversionActionModel),
        .number = RIAIDADActionModel_FieldNumber_Conversion,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(RIAIDADActionModel__storage_, conversion),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "step",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDADStepActionModel),
        .number = RIAIDADActionModel_FieldNumber_Step,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(RIAIDADActionModel__storage_, step),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "variableChange",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDADVariableChangeActionModel),
        .number = RIAIDADActionModel_FieldNumber_VariableChange,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(RIAIDADActionModel__storage_, variableChange),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "cancelDeviceMotion",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDADCancelDeviceMotionActionModel),
        .number = RIAIDADActionModel_FieldNumber_CancelDeviceMotion,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(RIAIDADActionModel__storage_, cancelDeviceMotion),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "vibrator",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDADVibratorActionModel),
        .number = RIAIDADActionModel_FieldNumber_Vibrator,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(RIAIDADActionModel__storage_, vibrator),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "beep",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDADBeepActionModel),
        .number = RIAIDADActionModel_FieldNumber_Beep,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(RIAIDADActionModel__storage_, beep),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "lottie",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDADLottieActionModel),
        .number = RIAIDADActionModel_FieldNumber_Lottie,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(RIAIDADActionModel__storage_, lottie),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "clickable",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDADClickableActionModel),
        .number = RIAIDADActionModel_FieldNumber_Clickable,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(RIAIDADActionModel__storage_, clickable),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "toast",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDADToastActionModel),
        .number = RIAIDADActionModel_FieldNumber_Toast,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(RIAIDADActionModel__storage_, toast),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "function",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDADExecuteFunctionActionModel),
        .number = RIAIDADActionModel_FieldNumber_Function,
        .hasIndex = 17,
        .offset = (uint32_t)offsetof(RIAIDADActionModel__storage_, function),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "dynamic",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDADDynamicTrackActionModel),
        .number = RIAIDADActionModel_FieldNumber_Dynamic,
        .hasIndex = 18,
        .offset = (uint32_t)offsetof(RIAIDADActionModel__storage_, dynamic),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RIAIDADActionModel class]
                                     rootClass:[RIAIDRiaidRoot class]
                                          file:RIAIDRiaidRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RIAIDADActionModel__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\004!!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RIAIDADClickableActionModel

@implementation RIAIDADClickableActionModel

@dynamic viewKey;
@dynamic clickable;

typedef struct RIAIDADClickableActionModel__storage_ {
  uint32_t _has_storage_[1];
  int32_t viewKey;
} RIAIDADClickableActionModel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "viewKey",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDADClickableActionModel_FieldNumber_ViewKey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RIAIDADClickableActionModel__storage_, viewKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "clickable",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDADClickableActionModel_FieldNumber_Clickable,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RIAIDADClickableActionModel class]
                                     rootClass:[RIAIDRiaidRoot class]
                                          file:RIAIDRiaidRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RIAIDADClickableActionModel__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RIAIDADToastActionModel

@implementation RIAIDADToastActionModel

@dynamic content;
@dynamic toastType;
@dynamic hasDuration, duration;

typedef struct RIAIDADToastActionModel__storage_ {
  uint32_t _has_storage_[1];
  RIAIDADToastActionModel_ToastType toastType;
  NSString *content;
  RIAIDInt32Value *duration;
} RIAIDADToastActionModel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "content",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDADToastActionModel_FieldNumber_Content,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RIAIDADToastActionModel__storage_, content),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "toastType",
        .dataTypeSpecific.enumDescFunc = RIAIDADToastActionModel_ToastType_EnumDescriptor,
        .number = RIAIDADToastActionModel_FieldNumber_ToastType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RIAIDADToastActionModel__storage_, toastType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "duration",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDInt32Value),
        .number = RIAIDADToastActionModel_FieldNumber_Duration,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RIAIDADToastActionModel__storage_, duration),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RIAIDADToastActionModel class]
                                     rootClass:[RIAIDRiaidRoot class]
                                          file:RIAIDRiaidRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RIAIDADToastActionModel__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RIAIDADToastActionModel_ToastType_RawValue(RIAIDADToastActionModel *message) {
  GPBDescriptor *descriptor = [RIAIDADToastActionModel descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RIAIDADToastActionModel_FieldNumber_ToastType];
  return GPBGetMessageInt32Field(message, field);
}

void SetRIAIDADToastActionModel_ToastType_RawValue(RIAIDADToastActionModel *message, int32_t value) {
  GPBDescriptor *descriptor = [RIAIDADToastActionModel descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RIAIDADToastActionModel_FieldNumber_ToastType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum RIAIDADToastActionModel_ToastType

GPBEnumDescriptor *RIAIDADToastActionModel_ToastType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Info\000Notify\000Alert\000";
    static const int32_t values[] = {
        RIAIDADToastActionModel_ToastType_Info,
        RIAIDADToastActionModel_ToastType_Notify,
        RIAIDADToastActionModel_ToastType_Alert,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(RIAIDADToastActionModel_ToastType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:RIAIDADToastActionModel_ToastType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL RIAIDADToastActionModel_ToastType_IsValidValue(int32_t value__) {
  switch (value__) {
    case RIAIDADToastActionModel_ToastType_Info:
    case RIAIDADToastActionModel_ToastType_Notify:
    case RIAIDADToastActionModel_ToastType_Alert:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - RIAIDADExecuteFunctionActionModel

@implementation RIAIDADExecuteFunctionActionModel

@dynamic functionKeysArray, functionKeysArray_Count;

typedef struct RIAIDADExecuteFunctionActionModel__storage_ {
  uint32_t _has_storage_[1];
  GPBInt32Array *functionKeysArray;
} RIAIDADExecuteFunctionActionModel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "functionKeysArray",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDADExecuteFunctionActionModel_FieldNumber_FunctionKeysArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RIAIDADExecuteFunctionActionModel__storage_, functionKeysArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RIAIDADExecuteFunctionActionModel class]
                                     rootClass:[RIAIDRiaidRoot class]
                                          file:RIAIDRiaidRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RIAIDADExecuteFunctionActionModel__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RIAIDADBeepActionModel

@implementation RIAIDADBeepActionModel

@dynamic URL;

typedef struct RIAIDADBeepActionModel__storage_ {
  uint32_t _has_storage_[1];
  NSString *URL;
} RIAIDADBeepActionModel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDADBeepActionModel_FieldNumber_URL,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RIAIDADBeepActionModel__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RIAIDADBeepActionModel class]
                                     rootClass:[RIAIDRiaidRoot class]
                                          file:RIAIDRiaidRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RIAIDADBeepActionModel__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001!!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RIAIDADVibratorActionModel

@implementation RIAIDADVibratorActionModel


typedef struct RIAIDADVibratorActionModel__storage_ {
  uint32_t _has_storage_[1];
} RIAIDADVibratorActionModel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RIAIDADVibratorActionModel class]
                                     rootClass:[RIAIDRiaidRoot class]
                                          file:RIAIDRiaidRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(RIAIDADVibratorActionModel__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RIAIDADCancelDeviceMotionActionModel

@implementation RIAIDADCancelDeviceMotionActionModel

@dynamic triggerKey;

typedef struct RIAIDADCancelDeviceMotionActionModel__storage_ {
  uint32_t _has_storage_[1];
  int32_t triggerKey;
} RIAIDADCancelDeviceMotionActionModel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "triggerKey",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDADCancelDeviceMotionActionModel_FieldNumber_TriggerKey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RIAIDADCancelDeviceMotionActionModel__storage_, triggerKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RIAIDADCancelDeviceMotionActionModel class]
                                     rootClass:[RIAIDRiaidRoot class]
                                          file:RIAIDRiaidRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RIAIDADCancelDeviceMotionActionModel__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RIAIDADTransitionActionModel

@implementation RIAIDADTransitionActionModel

@dynamic key;
@dynamic transitionsArray, transitionsArray_Count;

typedef struct RIAIDADTransitionActionModel__storage_ {
  uint32_t _has_storage_[1];
  int32_t key;
  NSMutableArray *transitionsArray;
} RIAIDADTransitionActionModel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "key",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDADTransitionActionModel_FieldNumber_Key,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RIAIDADTransitionActionModel__storage_, key),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "transitionsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDADTransitionModel),
        .number = RIAIDADTransitionActionModel_FieldNumber_TransitionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RIAIDADTransitionActionModel__storage_, transitionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RIAIDADTransitionActionModel class]
                                     rootClass:[RIAIDRiaidRoot class]
                                          file:RIAIDRiaidRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RIAIDADTransitionActionModel__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RIAIDADStepActionModel

@implementation RIAIDADStepActionModel

@dynamic max;
@dynamic min;
@dynamic step;
@dynamic variableKey;
@dynamic triggerKeysArray, triggerKeysArray_Count;

typedef struct RIAIDADStepActionModel__storage_ {
  uint32_t _has_storage_[1];
  int32_t max;
  int32_t min;
  int32_t step;
  int32_t variableKey;
  GPBInt32Array *triggerKeysArray;
} RIAIDADStepActionModel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "max",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDADStepActionModel_FieldNumber_Max,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RIAIDADStepActionModel__storage_, max),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "min",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDADStepActionModel_FieldNumber_Min,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RIAIDADStepActionModel__storage_, min),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "step",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDADStepActionModel_FieldNumber_Step,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RIAIDADStepActionModel__storage_, step),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "variableKey",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDADStepActionModel_FieldNumber_VariableKey,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RIAIDADStepActionModel__storage_, variableKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "triggerKeysArray",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDADStepActionModel_FieldNumber_TriggerKeysArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RIAIDADStepActionModel__storage_, triggerKeysArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RIAIDADStepActionModel class]
                                     rootClass:[RIAIDRiaidRoot class]
                                          file:RIAIDRiaidRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RIAIDADStepActionModel__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RIAIDADTrackActionModel

@implementation RIAIDADTrackActionModel

@dynamic parameters, parameters_Count;
@dynamic hasDynamic, dynamic;

typedef struct RIAIDADTrackActionModel__storage_ {
  uint32_t _has_storage_[1];
  NSMutableDictionary *parameters;
  RIAIDADDynamicTrackActionModel *dynamic;
} RIAIDADTrackActionModel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "parameters",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDADTrackActionModel_FieldNumber_Parameters,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RIAIDADTrackActionModel__storage_, parameters),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "dynamic",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDADDynamicTrackActionModel),
        .number = RIAIDADTrackActionModel_FieldNumber_Dynamic,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RIAIDADTrackActionModel__storage_, dynamic),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RIAIDADTrackActionModel class]
                                     rootClass:[RIAIDRiaidRoot class]
                                          file:RIAIDRiaidRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RIAIDADTrackActionModel__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RIAIDADVideoActionModel

@implementation RIAIDADVideoActionModel

@dynamic type;
@dynamic viewKey;

typedef struct RIAIDADVideoActionModel__storage_ {
  uint32_t _has_storage_[1];
  RIAIDADVideoActionModel_VideoControlType type;
  int32_t viewKey;
} RIAIDADVideoActionModel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = RIAIDADVideoActionModel_VideoControlType_EnumDescriptor,
        .number = RIAIDADVideoActionModel_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RIAIDADVideoActionModel__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "viewKey",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDADVideoActionModel_FieldNumber_ViewKey,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RIAIDADVideoActionModel__storage_, viewKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RIAIDADVideoActionModel class]
                                     rootClass:[RIAIDRiaidRoot class]
                                          file:RIAIDRiaidRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RIAIDADVideoActionModel__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RIAIDADVideoActionModel_Type_RawValue(RIAIDADVideoActionModel *message) {
  GPBDescriptor *descriptor = [RIAIDADVideoActionModel descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RIAIDADVideoActionModel_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetRIAIDADVideoActionModel_Type_RawValue(RIAIDADVideoActionModel *message, int32_t value) {
  GPBDescriptor *descriptor = [RIAIDADVideoActionModel descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RIAIDADVideoActionModel_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum RIAIDADVideoActionModel_VideoControlType

GPBEnumDescriptor *RIAIDADVideoActionModel_VideoControlType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "VideoNone\000VideoReplay\000VideoPositionReset"
        "\000VideoPause\000VideoPlay\000VideoSoundTurnOn\000V"
        "ideoSoundTurnOff\000";
    static const int32_t values[] = {
        RIAIDADVideoActionModel_VideoControlType_VideoNone,
        RIAIDADVideoActionModel_VideoControlType_VideoReplay,
        RIAIDADVideoActionModel_VideoControlType_VideoPositionReset,
        RIAIDADVideoActionModel_VideoControlType_VideoPause,
        RIAIDADVideoActionModel_VideoControlType_VideoPlay,
        RIAIDADVideoActionModel_VideoControlType_VideoSoundTurnOn,
        RIAIDADVideoActionModel_VideoControlType_VideoSoundTurnOff,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(RIAIDADVideoActionModel_VideoControlType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:RIAIDADVideoActionModel_VideoControlType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL RIAIDADVideoActionModel_VideoControlType_IsValidValue(int32_t value__) {
  switch (value__) {
    case RIAIDADVideoActionModel_VideoControlType_VideoNone:
    case RIAIDADVideoActionModel_VideoControlType_VideoReplay:
    case RIAIDADVideoActionModel_VideoControlType_VideoPositionReset:
    case RIAIDADVideoActionModel_VideoControlType_VideoPause:
    case RIAIDADVideoActionModel_VideoControlType_VideoPlay:
    case RIAIDADVideoActionModel_VideoControlType_VideoSoundTurnOn:
    case RIAIDADVideoActionModel_VideoControlType_VideoSoundTurnOff:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - RIAIDADLottieActionModel

@implementation RIAIDADLottieActionModel

@dynamic type;
@dynamic viewKey;

typedef struct RIAIDADLottieActionModel__storage_ {
  uint32_t _has_storage_[1];
  RIAIDADLottieActionModel_LottieControlType type;
  int32_t viewKey;
} RIAIDADLottieActionModel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = RIAIDADLottieActionModel_LottieControlType_EnumDescriptor,
        .number = RIAIDADLottieActionModel_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RIAIDADLottieActionModel__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "viewKey",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDADLottieActionModel_FieldNumber_ViewKey,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RIAIDADLottieActionModel__storage_, viewKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RIAIDADLottieActionModel class]
                                     rootClass:[RIAIDRiaidRoot class]
                                          file:RIAIDRiaidRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RIAIDADLottieActionModel__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RIAIDADLottieActionModel_Type_RawValue(RIAIDADLottieActionModel *message) {
  GPBDescriptor *descriptor = [RIAIDADLottieActionModel descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RIAIDADLottieActionModel_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetRIAIDADLottieActionModel_Type_RawValue(RIAIDADLottieActionModel *message, int32_t value) {
  GPBDescriptor *descriptor = [RIAIDADLottieActionModel descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RIAIDADLottieActionModel_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum RIAIDADLottieActionModel_LottieControlType

GPBEnumDescriptor *RIAIDADLottieActionModel_LottieControlType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "LottieNone\000LottieReplay\000LottiePositionRe"
        "set\000LottiePause\000LottiePlay\000";
    static const int32_t values[] = {
        RIAIDADLottieActionModel_LottieControlType_LottieNone,
        RIAIDADLottieActionModel_LottieControlType_LottieReplay,
        RIAIDADLottieActionModel_LottieControlType_LottiePositionReset,
        RIAIDADLottieActionModel_LottieControlType_LottiePause,
        RIAIDADLottieActionModel_LottieControlType_LottiePlay,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(RIAIDADLottieActionModel_LottieControlType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:RIAIDADLottieActionModel_LottieControlType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL RIAIDADLottieActionModel_LottieControlType_IsValidValue(int32_t value__) {
  switch (value__) {
    case RIAIDADLottieActionModel_LottieControlType_LottieNone:
    case RIAIDADLottieActionModel_LottieControlType_LottieReplay:
    case RIAIDADLottieActionModel_LottieControlType_LottiePositionReset:
    case RIAIDADLottieActionModel_LottieControlType_LottiePause:
    case RIAIDADLottieActionModel_LottieControlType_LottiePlay:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - RIAIDADUrlActionModel

@implementation RIAIDADUrlActionModel

@dynamic URL;
@dynamic bundle, bundle_Count;

typedef struct RIAIDADUrlActionModel__storage_ {
  uint32_t _has_storage_[1];
  NSString *URL;
  NSMutableDictionary *bundle;
} RIAIDADUrlActionModel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDADUrlActionModel_FieldNumber_URL,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RIAIDADUrlActionModel__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bundle",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDADUrlActionModel_FieldNumber_Bundle,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RIAIDADUrlActionModel__storage_, bundle),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RIAIDADUrlActionModel class]
                                     rootClass:[RIAIDRiaidRoot class]
                                          file:RIAIDRiaidRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RIAIDADUrlActionModel__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001!!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RIAIDADConversionActionModel

@implementation RIAIDADConversionActionModel

@dynamic URL;
@dynamic deepLink;
@dynamic bundle, bundle_Count;

typedef struct RIAIDADConversionActionModel__storage_ {
  uint32_t _has_storage_[1];
  NSString *URL;
  NSString *deepLink;
  NSMutableDictionary *bundle;
} RIAIDADConversionActionModel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDADConversionActionModel_FieldNumber_URL,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RIAIDADConversionActionModel__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "deepLink",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDADConversionActionModel_FieldNumber_DeepLink,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RIAIDADConversionActionModel__storage_, deepLink),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bundle",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDADConversionActionModel_FieldNumber_Bundle,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RIAIDADConversionActionModel__storage_, bundle),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RIAIDADConversionActionModel class]
                                     rootClass:[RIAIDRiaidRoot class]
                                          file:RIAIDRiaidRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RIAIDADConversionActionModel__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001!!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RIAIDADConditionChangeActionModel

@implementation RIAIDADConditionChangeActionModel

@dynamic hasCondition, condition;

typedef struct RIAIDADConditionChangeActionModel__storage_ {
  uint32_t _has_storage_[1];
  RIAIDADConditionModel *condition;
} RIAIDADConditionChangeActionModel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "condition",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDADConditionModel),
        .number = RIAIDADConditionChangeActionModel_FieldNumber_Condition,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RIAIDADConditionChangeActionModel__storage_, condition),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RIAIDADConditionChangeActionModel class]
                                     rootClass:[RIAIDRiaidRoot class]
                                          file:RIAIDRiaidRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RIAIDADConditionChangeActionModel__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RIAIDADVariableChangeActionModel

@implementation RIAIDADVariableChangeActionModel

@dynamic hasVariable, variable;

typedef struct RIAIDADVariableChangeActionModel__storage_ {
  uint32_t _has_storage_[1];
  RIAIDBasicVariable *variable;
} RIAIDADVariableChangeActionModel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "variable",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDBasicVariable),
        .number = RIAIDADVariableChangeActionModel_FieldNumber_Variable,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RIAIDADVariableChangeActionModel__storage_, variable),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RIAIDADVariableChangeActionModel class]
                                     rootClass:[RIAIDRiaidRoot class]
                                          file:RIAIDRiaidRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RIAIDADVariableChangeActionModel__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RIAIDADCancelTimerActionModel

@implementation RIAIDADCancelTimerActionModel

@dynamic triggerKey;

typedef struct RIAIDADCancelTimerActionModel__storage_ {
  uint32_t _has_storage_[1];
  int32_t triggerKey;
} RIAIDADCancelTimerActionModel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "triggerKey",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDADCancelTimerActionModel_FieldNumber_TriggerKey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RIAIDADCancelTimerActionModel__storage_, triggerKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RIAIDADCancelTimerActionModel class]
                                     rootClass:[RIAIDRiaidRoot class]
                                          file:RIAIDRiaidRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RIAIDADCancelTimerActionModel__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RIAIDADCustomActionModel

@implementation RIAIDADCustomActionModel

@dynamic parameters, parameters_Count;

typedef struct RIAIDADCustomActionModel__storage_ {
  uint32_t _has_storage_[1];
  NSMutableDictionary *parameters;
} RIAIDADCustomActionModel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "parameters",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDADCustomActionModel_FieldNumber_Parameters,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RIAIDADCustomActionModel__storage_, parameters),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RIAIDADCustomActionModel class]
                                     rootClass:[RIAIDRiaidRoot class]
                                          file:RIAIDRiaidRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RIAIDADCustomActionModel__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RIAIDADTriggerActionModel

@implementation RIAIDADTriggerActionModel

@dynamic triggerKeysArray, triggerKeysArray_Count;

typedef struct RIAIDADTriggerActionModel__storage_ {
  uint32_t _has_storage_[1];
  GPBInt32Array *triggerKeysArray;
} RIAIDADTriggerActionModel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "triggerKeysArray",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDADTriggerActionModel_FieldNumber_TriggerKeysArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RIAIDADTriggerActionModel__storage_, triggerKeysArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RIAIDADTriggerActionModel class]
                                     rootClass:[RIAIDRiaidRoot class]
                                          file:RIAIDRiaidRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RIAIDADTriggerActionModel__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RIAIDADDynamicTrackActionModel

@implementation RIAIDADDynamicTrackActionModel

@dynamic script;

typedef struct RIAIDADDynamicTrackActionModel__storage_ {
  uint32_t _has_storage_[1];
  NSString *script;
} RIAIDADDynamicTrackActionModel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "script",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDADDynamicTrackActionModel_FieldNumber_Script,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RIAIDADDynamicTrackActionModel__storage_, script),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RIAIDADDynamicTrackActionModel class]
                                     rootClass:[RIAIDRiaidRoot class]
                                          file:RIAIDRiaidRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RIAIDADDynamicTrackActionModel__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RIAIDADRenderWrapModel

@implementation RIAIDADRenderWrapModel

@dynamic hasRenderData, renderData;

typedef struct RIAIDADRenderWrapModel__storage_ {
  uint32_t _has_storage_[1];
  RIAIDNode *renderData;
} RIAIDADRenderWrapModel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "renderData",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDNode),
        .number = RIAIDADRenderWrapModel_FieldNumber_RenderData,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RIAIDADRenderWrapModel__storage_, renderData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RIAIDADRenderWrapModel class]
                                     rootClass:[RIAIDRiaidRoot class]
                                          file:RIAIDRiaidRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RIAIDADRenderWrapModel__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RIAIDADSceneLifeCycleModel

@implementation RIAIDADSceneLifeCycleModel

@dynamic appearTriggerKeysArray, appearTriggerKeysArray_Count;
@dynamic disappearTriggerKeysArray, disappearTriggerKeysArray_Count;

typedef struct RIAIDADSceneLifeCycleModel__storage_ {
  uint32_t _has_storage_[1];
  GPBInt32Array *appearTriggerKeysArray;
  GPBInt32Array *disappearTriggerKeysArray;
} RIAIDADSceneLifeCycleModel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "appearTriggerKeysArray",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDADSceneLifeCycleModel_FieldNumber_AppearTriggerKeysArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RIAIDADSceneLifeCycleModel__storage_, appearTriggerKeysArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "disappearTriggerKeysArray",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDADSceneLifeCycleModel_FieldNumber_DisappearTriggerKeysArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RIAIDADSceneLifeCycleModel__storage_, disappearTriggerKeysArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RIAIDADSceneLifeCycleModel class]
                                     rootClass:[RIAIDRiaidRoot class]
                                          file:RIAIDRiaidRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RIAIDADSceneLifeCycleModel__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RIAIDADBrowserLifeCycleModel

@implementation RIAIDADBrowserLifeCycleModel

@dynamic appearTriggerKeysArray, appearTriggerKeysArray_Count;
@dynamic disappearTriggerKeysArray, disappearTriggerKeysArray_Count;
@dynamic loadTriggerKeysArray, loadTriggerKeysArray_Count;
@dynamic unloadTriggerKeysArray, unloadTriggerKeysArray_Count;

typedef struct RIAIDADBrowserLifeCycleModel__storage_ {
  uint32_t _has_storage_[1];
  GPBInt32Array *appearTriggerKeysArray;
  GPBInt32Array *disappearTriggerKeysArray;
  GPBInt32Array *loadTriggerKeysArray;
  GPBInt32Array *unloadTriggerKeysArray;
} RIAIDADBrowserLifeCycleModel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "appearTriggerKeysArray",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDADBrowserLifeCycleModel_FieldNumber_AppearTriggerKeysArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RIAIDADBrowserLifeCycleModel__storage_, appearTriggerKeysArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "disappearTriggerKeysArray",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDADBrowserLifeCycleModel_FieldNumber_DisappearTriggerKeysArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RIAIDADBrowserLifeCycleModel__storage_, disappearTriggerKeysArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "loadTriggerKeysArray",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDADBrowserLifeCycleModel_FieldNumber_LoadTriggerKeysArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RIAIDADBrowserLifeCycleModel__storage_, loadTriggerKeysArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "unloadTriggerKeysArray",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDADBrowserLifeCycleModel_FieldNumber_UnloadTriggerKeysArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RIAIDADBrowserLifeCycleModel__storage_, unloadTriggerKeysArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RIAIDADBrowserLifeCycleModel class]
                                     rootClass:[RIAIDRiaidRoot class]
                                          file:RIAIDRiaidRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RIAIDADBrowserLifeCycleModel__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RIAIDADSceneModel

@implementation RIAIDADSceneModel

@dynamic key;
@dynamic hasRender, render;
@dynamic debugInfo;
@dynamic hasLifeCycle, lifeCycle;

typedef struct RIAIDADSceneModel__storage_ {
  uint32_t _has_storage_[1];
  int32_t key;
  RIAIDADRenderWrapModel *render;
  NSString *debugInfo;
  RIAIDADSceneLifeCycleModel *lifeCycle;
} RIAIDADSceneModel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "key",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDADSceneModel_FieldNumber_Key,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RIAIDADSceneModel__storage_, key),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "render",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDADRenderWrapModel),
        .number = RIAIDADSceneModel_FieldNumber_Render,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RIAIDADSceneModel__storage_, render),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "debugInfo",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDADSceneModel_FieldNumber_DebugInfo,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RIAIDADSceneModel__storage_, debugInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "lifeCycle",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDADSceneLifeCycleModel),
        .number = RIAIDADSceneModel_FieldNumber_LifeCycle,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RIAIDADSceneModel__storage_, lifeCycle),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RIAIDADSceneModel class]
                                     rootClass:[RIAIDRiaidRoot class]
                                          file:RIAIDRiaidRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RIAIDADSceneModel__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RIAIDADSceneRelationModel

@implementation RIAIDADSceneRelationModel

@dynamic sourceKey;
@dynamic targetKey;
@dynamic distance;
@dynamic sourceEdge;
@dynamic targetEdge;

typedef struct RIAIDADSceneRelationModel__storage_ {
  uint32_t _has_storage_[1];
  int32_t sourceKey;
  int32_t targetKey;
  float distance;
  RIAIDADSceneRelationModel_SceneEdge sourceEdge;
  RIAIDADSceneRelationModel_SceneEdge targetEdge;
} RIAIDADSceneRelationModel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sourceKey",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDADSceneRelationModel_FieldNumber_SourceKey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RIAIDADSceneRelationModel__storage_, sourceKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "targetKey",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDADSceneRelationModel_FieldNumber_TargetKey,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RIAIDADSceneRelationModel__storage_, targetKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "distance",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDADSceneRelationModel_FieldNumber_Distance,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RIAIDADSceneRelationModel__storage_, distance),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "sourceEdge",
        .dataTypeSpecific.enumDescFunc = RIAIDADSceneRelationModel_SceneEdge_EnumDescriptor,
        .number = RIAIDADSceneRelationModel_FieldNumber_SourceEdge,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RIAIDADSceneRelationModel__storage_, sourceEdge),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "targetEdge",
        .dataTypeSpecific.enumDescFunc = RIAIDADSceneRelationModel_SceneEdge_EnumDescriptor,
        .number = RIAIDADSceneRelationModel_FieldNumber_TargetEdge,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(RIAIDADSceneRelationModel__storage_, targetEdge),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RIAIDADSceneRelationModel class]
                                     rootClass:[RIAIDRiaidRoot class]
                                          file:RIAIDRiaidRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RIAIDADSceneRelationModel__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RIAIDADSceneRelationModel_SourceEdge_RawValue(RIAIDADSceneRelationModel *message) {
  GPBDescriptor *descriptor = [RIAIDADSceneRelationModel descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RIAIDADSceneRelationModel_FieldNumber_SourceEdge];
  return GPBGetMessageInt32Field(message, field);
}

void SetRIAIDADSceneRelationModel_SourceEdge_RawValue(RIAIDADSceneRelationModel *message, int32_t value) {
  GPBDescriptor *descriptor = [RIAIDADSceneRelationModel descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RIAIDADSceneRelationModel_FieldNumber_SourceEdge];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t RIAIDADSceneRelationModel_TargetEdge_RawValue(RIAIDADSceneRelationModel *message) {
  GPBDescriptor *descriptor = [RIAIDADSceneRelationModel descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RIAIDADSceneRelationModel_FieldNumber_TargetEdge];
  return GPBGetMessageInt32Field(message, field);
}

void SetRIAIDADSceneRelationModel_TargetEdge_RawValue(RIAIDADSceneRelationModel *message, int32_t value) {
  GPBDescriptor *descriptor = [RIAIDADSceneRelationModel descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RIAIDADSceneRelationModel_FieldNumber_TargetEdge];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum RIAIDADSceneRelationModel_SceneEdge

GPBEnumDescriptor *RIAIDADSceneRelationModel_SceneEdge_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "SceneEdgeNone\000Start\000Top\000End\000Bottom\000";
    static const int32_t values[] = {
        RIAIDADSceneRelationModel_SceneEdge_SceneEdgeNone,
        RIAIDADSceneRelationModel_SceneEdge_Start,
        RIAIDADSceneRelationModel_SceneEdge_Top,
        RIAIDADSceneRelationModel_SceneEdge_End,
        RIAIDADSceneRelationModel_SceneEdge_Bottom,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(RIAIDADSceneRelationModel_SceneEdge)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:RIAIDADSceneRelationModel_SceneEdge_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL RIAIDADSceneRelationModel_SceneEdge_IsValidValue(int32_t value__) {
  switch (value__) {
    case RIAIDADSceneRelationModel_SceneEdge_SceneEdgeNone:
    case RIAIDADSceneRelationModel_SceneEdge_Start:
    case RIAIDADSceneRelationModel_SceneEdge_Top:
    case RIAIDADSceneRelationModel_SceneEdge_End:
    case RIAIDADSceneRelationModel_SceneEdge_Bottom:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - RIAIDADFunctionModel

@implementation RIAIDADFunctionModel

@dynamic hasReadAttribute, readAttribute;
@dynamic hasAppInstalled, appInstalled;

typedef struct RIAIDADFunctionModel__storage_ {
  uint32_t _has_storage_[1];
  RIAIDADReadAttributeFunctionModel *readAttribute;
  RIAIDADAppInstalledFunctionModel *appInstalled;
} RIAIDADFunctionModel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "readAttribute",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDADReadAttributeFunctionModel),
        .number = RIAIDADFunctionModel_FieldNumber_ReadAttribute,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RIAIDADFunctionModel__storage_, readAttribute),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "appInstalled",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDADAppInstalledFunctionModel),
        .number = RIAIDADFunctionModel_FieldNumber_AppInstalled,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RIAIDADFunctionModel__storage_, appInstalled),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RIAIDADFunctionModel class]
                                     rootClass:[RIAIDRiaidRoot class]
                                          file:RIAIDRiaidRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RIAIDADFunctionModel__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RIAIDADReadAttributeFunctionModel

@implementation RIAIDADReadAttributeFunctionModel

@dynamic key;
@dynamic viewKey;
@dynamic attributeType;

typedef struct RIAIDADReadAttributeFunctionModel__storage_ {
  uint32_t _has_storage_[1];
  int32_t key;
  int32_t viewKey;
  RIAIDAttributes_AttributeType attributeType;
} RIAIDADReadAttributeFunctionModel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "key",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDADReadAttributeFunctionModel_FieldNumber_Key,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RIAIDADReadAttributeFunctionModel__storage_, key),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "viewKey",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDADReadAttributeFunctionModel_FieldNumber_ViewKey,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RIAIDADReadAttributeFunctionModel__storage_, viewKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "attributeType",
        .dataTypeSpecific.enumDescFunc = RIAIDAttributes_AttributeType_EnumDescriptor,
        .number = RIAIDADReadAttributeFunctionModel_FieldNumber_AttributeType,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RIAIDADReadAttributeFunctionModel__storage_, attributeType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RIAIDADReadAttributeFunctionModel class]
                                     rootClass:[RIAIDRiaidRoot class]
                                          file:RIAIDRiaidRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RIAIDADReadAttributeFunctionModel__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RIAIDADReadAttributeFunctionModel_AttributeType_RawValue(RIAIDADReadAttributeFunctionModel *message) {
  GPBDescriptor *descriptor = [RIAIDADReadAttributeFunctionModel descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RIAIDADReadAttributeFunctionModel_FieldNumber_AttributeType];
  return GPBGetMessageInt32Field(message, field);
}

void SetRIAIDADReadAttributeFunctionModel_AttributeType_RawValue(RIAIDADReadAttributeFunctionModel *message, int32_t value) {
  GPBDescriptor *descriptor = [RIAIDADReadAttributeFunctionModel descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RIAIDADReadAttributeFunctionModel_FieldNumber_AttributeType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - RIAIDADAppInstalledFunctionModel

@implementation RIAIDADAppInstalledFunctionModel

@dynamic key;
@dynamic appPkgNamesArray, appPkgNamesArray_Count;
@dynamic variableKey;

typedef struct RIAIDADAppInstalledFunctionModel__storage_ {
  uint32_t _has_storage_[1];
  int32_t key;
  int32_t variableKey;
  NSMutableArray *appPkgNamesArray;
} RIAIDADAppInstalledFunctionModel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "key",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDADAppInstalledFunctionModel_FieldNumber_Key,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RIAIDADAppInstalledFunctionModel__storage_, key),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "appPkgNamesArray",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDADAppInstalledFunctionModel_FieldNumber_AppPkgNamesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RIAIDADAppInstalledFunctionModel__storage_, appPkgNamesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "variableKey",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDADAppInstalledFunctionModel_FieldNumber_VariableKey,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RIAIDADAppInstalledFunctionModel__storage_, variableKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RIAIDADAppInstalledFunctionModel class]
                                     rootClass:[RIAIDRiaidRoot class]
                                          file:RIAIDRiaidRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RIAIDADAppInstalledFunctionModel__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RIAIDRiaidModel

@implementation RIAIDRiaidModel

@dynamic hasLifeCycle, lifeCycle;
@dynamic scenesArray, scenesArray_Count;
@dynamic defaultSceneRelationsArray, defaultSceneRelationsArray_Count;
@dynamic triggersArray, triggersArray_Count;
@dynamic defaultConditionsArray, defaultConditionsArray_Count;
@dynamic defaultVariablesArray, defaultVariablesArray_Count;
@dynamic functionsArray, functionsArray_Count;
@dynamic exportTriggerKeysArray, exportTriggerKeysArray_Count;
@dynamic key;

typedef struct RIAIDRiaidModel__storage_ {
  uint32_t _has_storage_[1];
  RIAIDADBrowserLifeCycleModel *lifeCycle;
  NSMutableArray *scenesArray;
  NSMutableArray *defaultSceneRelationsArray;
  NSMutableArray *triggersArray;
  NSMutableArray *defaultConditionsArray;
  NSMutableArray *defaultVariablesArray;
  NSMutableArray *functionsArray;
  GPBInt32Array *exportTriggerKeysArray;
  NSString *key;
} RIAIDRiaidModel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "lifeCycle",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDADBrowserLifeCycleModel),
        .number = RIAIDRiaidModel_FieldNumber_LifeCycle,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RIAIDRiaidModel__storage_, lifeCycle),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "scenesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDADSceneModel),
        .number = RIAIDRiaidModel_FieldNumber_ScenesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RIAIDRiaidModel__storage_, scenesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "defaultSceneRelationsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDADSceneRelationModel),
        .number = RIAIDRiaidModel_FieldNumber_DefaultSceneRelationsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RIAIDRiaidModel__storage_, defaultSceneRelationsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "triggersArray",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDADTriggerModel),
        .number = RIAIDRiaidModel_FieldNumber_TriggersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RIAIDRiaidModel__storage_, triggersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "defaultConditionsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDADConditionModel),
        .number = RIAIDRiaidModel_FieldNumber_DefaultConditionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RIAIDRiaidModel__storage_, defaultConditionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "defaultVariablesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDBasicVariable),
        .number = RIAIDRiaidModel_FieldNumber_DefaultVariablesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RIAIDRiaidModel__storage_, defaultVariablesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "functionsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(RIAIDADFunctionModel),
        .number = RIAIDRiaidModel_FieldNumber_FunctionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RIAIDRiaidModel__storage_, functionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "exportTriggerKeysArray",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDRiaidModel_FieldNumber_ExportTriggerKeysArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RIAIDRiaidModel__storage_, exportTriggerKeysArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "key",
        .dataTypeSpecific.className = NULL,
        .number = RIAIDRiaidModel_FieldNumber_Key,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RIAIDRiaidModel__storage_, key),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RIAIDRiaidModel class]
                                     rootClass:[RIAIDRiaidRoot class]
                                          file:RIAIDRiaidRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RIAIDRiaidModel__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RIAIDSystemKeyEnum

@implementation RIAIDSystemKeyEnum


typedef struct RIAIDSystemKeyEnum__storage_ {
  uint32_t _has_storage_[1];
} RIAIDSystemKeyEnum__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RIAIDSystemKeyEnum class]
                                     rootClass:[RIAIDRiaidRoot class]
                                          file:RIAIDRiaidRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(RIAIDSystemKeyEnum__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum RIAIDSystemKeyEnum_SystemKeys

GPBEnumDescriptor *RIAIDSystemKeyEnum_SystemKeys_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "InvalidKey\000TriggerKeyAdVideoEnd\000SceneKey"
        "Canvas\000";
    static const int32_t values[] = {
        RIAIDSystemKeyEnum_SystemKeys_InvalidKey,
        RIAIDSystemKeyEnum_SystemKeys_TriggerKeyAdVideoEnd,
        RIAIDSystemKeyEnum_SystemKeys_SceneKeyCanvas,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(RIAIDSystemKeyEnum_SystemKeys)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:RIAIDSystemKeyEnum_SystemKeys_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL RIAIDSystemKeyEnum_SystemKeys_IsValidValue(int32_t value__) {
  switch (value__) {
    case RIAIDSystemKeyEnum_SystemKeys_InvalidKey:
    case RIAIDSystemKeyEnum_SystemKeys_TriggerKeyAdVideoEnd:
    case RIAIDSystemKeyEnum_SystemKeys_SceneKeyCanvas:
      return YES;
    default:
      return NO;
  }
}


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
